<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/04/27/SpringMVC%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/SpringMVC%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1、什么是-SpringMvc？"><a href="#1、什么是-SpringMvc？" class="headerlink" title="1、什么是 SpringMvc？"></a>1、什么是 SpringMvc？</h2><p>答：SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。 </p><h2 id="2、Spring-MVC-的优点：答："><a href="#2、Spring-MVC-的优点：答：" class="headerlink" title="2、Spring MVC 的优点：答："></a>2、Spring MVC 的优点：答：</h2><p>1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java 组件.并且和 Spring 提供的其他基础结构紧密集成.  </p><p>2）不依赖于 Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)  </p><p>3）可以任意使用各种视图技术,而不仅仅局限于 JSP  </p><p>4）支持各种请求资源的映射策略  </p><p>5）它应是易于扩展的 </p><h2 id="3、SpringMVC-工作原理？答："><a href="#3、SpringMVC-工作原理？答：" class="headerlink" title="3、SpringMVC 工作原理？答："></a>3、SpringMVC 工作原理？答：</h2><p>1）客户端发送请求到 DispatcherServlet </p><p>2）DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller  </p><p>3）Controller 调用业务逻辑后，返回 ModelAndView </p><p>4）DispatcherServlet 查询 ModelAndView，找到指定视图  </p><p>5）视图将结果返回到客户端 </p><h2 id="4、SpringMVC-流程？答："><a href="#4、SpringMVC-流程？答：" class="headerlink" title="4、SpringMVC 流程？答："></a>4、SpringMVC 流程？答：</h2><p> 1）  用户发送请求至前端控制器 DispatcherServlet。  </p><p> 2）  DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。 </p><p> 3）  处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。   </p><p>4）  DispatcherServlet 调用 HandlerAdapter 处理器适配器。</p><p>5）  HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。   </p><p>6）  Controller 执行完成返回 ModelAndView。   </p><p>7）  HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。   </p><p>8）  DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。   </p><p>9）  ViewReslover 解析后返回具体 View。   </p><p>10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。   </p><p>11）DispatcherServlet 响应用户。 </p><h2 id="6、SpringMvc-的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#6、SpringMvc-的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="6、SpringMvc 的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>6、SpringMvc 的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h2><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。 </p><h2 id="7、如果你也用过-struts2-简单介绍下-springMVC-和-struts2-的区别有哪些"><a href="#7、如果你也用过-struts2-简单介绍下-springMVC-和-struts2-的区别有哪些" class="headerlink" title="7、如果你也用过 struts2.简单介绍下 springMVC 和 struts2 的区别有哪些?"></a>7、如果你也用过 struts2.简单介绍下 springMVC 和 struts2 的区别有哪些?</h2><p>答：  </p><p>1）springmvc 的入口是一个 servlet 即前端控制器，而 struts2 入口是一个 filter 过虑器。 </p><p>2）springmvc 是基于方法开发(一个 url 对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例。 </p><p>3）Struts 采用值栈存储请求和响应的数据，通过 OGNL 存取数据，springmvc 通过参数解析器是将 request 请求内容解析，并给方法形参赋值，将数据和视图封装成 ModelAndView 对象，最后又将 ModelAndView 中的模型数据通过 reques 域传输到页面。Jsp 视图解析器默认使用 jstl。 </p><h2 id="8、-SpingMvc-中的控制器的注解一般用那个-有没有别的注解可以替代？"><a href="#8、-SpingMvc-中的控制器的注解一般用那个-有没有别的注解可以替代？" class="headerlink" title="8、  SpingMvc 中的控制器的注解一般用那个,有没有别的注解可以替代？"></a>8、  SpingMvc 中的控制器的注解一般用那个,有没有别的注解可以替代？</h2><p>答：一般用@Conntroller 注解,表示是表现层,不能用用别的注解代替。 </p><h2 id="9、-RequestMapping-注解用在类上面有什么作用？"><a href="#9、-RequestMapping-注解用在类上面有什么作用？" class="headerlink" title="9、  @RequestMapping 注解用在类上面有什么作用？"></a>9、  @RequestMapping 注解用在类上面有什么作用？</h2><p>答：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 </p><h2 id="10、怎么样把某个请求映射到特定的方法上面？"><a href="#10、怎么样把某个请求映射到特定的方法上面？" class="headerlink" title="10、怎么样把某个请求映射到特定的方法上面？"></a>10、怎么样把某个请求映射到特定的方法上面？</h2><p>答：直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径 </p><h2 id="11、如果在拦截请求中-我想拦截-get-方式提交的方法-怎么配置？"><a href="#11、如果在拦截请求中-我想拦截-get-方式提交的方法-怎么配置？" class="headerlink" title="11、如果在拦截请求中,我想拦截 get 方式提交的方法,怎么配置？"></a>11、如果在拦截请求中,我想拦截 get 方式提交的方法,怎么配置？</h2><p>答：可以在@RequestMapping 注解里面加上 method&#x3D;RequestMethod.GET</p><h2 id="12、怎么样在方法里面得到-Request-或者-Session？"><a href="#12、怎么样在方法里面得到-Request-或者-Session？" class="headerlink" title="12、怎么样在方法里面得到 Request,或者 Session？"></a>12、怎么样在方法里面得到 Request,或者 Session？</h2><p>答：直接在方法的形参中声明 request,SpringMvc 就自动把 request 对象传入 </p><h2 id="13、我想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#13、我想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="13、我想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>13、我想在拦截的方法里面得到从前台传入的参数,怎么得到？</h2><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样 </p><h2 id="14、如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#14、如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="14、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>14、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h2><p>答：直接在方法中声明这个对象,SpringMvc 就自动会把属性赋值到这个对象里面。 </p><h2 id="15、SpringMvc-中函数的返回值是什么？"><a href="#15、SpringMvc-中函数的返回值是什么？" class="headerlink" title="15、SpringMvc 中函数的返回值是什么？"></a>15、SpringMvc 中函数的返回值是什么？</h2><p>答：返回值可以有很多类型,有 String, ModelAndView,当一般用 String 比较好。 </p><h2 id="16、SpringMVC-怎么样设定重定向和转发的？"><a href="#16、SpringMVC-怎么样设定重定向和转发的？" class="headerlink" title="16、SpringMVC 怎么样设定重定向和转发的？"></a>16、SpringMVC 怎么样设定重定向和转发的？</h2><p>答：在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name&#x3D;method4” 在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect:<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a></p><h2 id="17、SpringMvc-用什么对象从后台向前台传递数据的？"><a href="#17、SpringMvc-用什么对象从后台向前台传递数据的？" class="headerlink" title="17、SpringMvc 用什么对象从后台向前台传递数据的？"></a>17、SpringMvc 用什么对象从后台向前台传递数据的？</h2><p>答：通过 ModelMap 对象,可以在这个对象里面用 put 方法,把对象加到里面,前台就可以通过 el 表达式拿到。 </p><h2 id="18、SpringMvc-中有个类把视图和数据都合并的一起的-叫什么？"><a href="#18、SpringMvc-中有个类把视图和数据都合并的一起的-叫什么？" class="headerlink" title="18、SpringMvc 中有个类把视图和数据都合并的一起的,叫什么？"></a>18、SpringMvc 中有个类把视图和数据都合并的一起的,叫什么？</h2><p>答：叫 ModelAndView。 </p><h2 id="19、怎么样把-ModelMap-里面的数据放入-Session-里面？"><a href="#19、怎么样把-ModelMap-里面的数据放入-Session-里面？" class="headerlink" title="19、怎么样把 ModelMap 里面的数据放入 Session 里面？"></a>19、怎么样把 ModelMap 里面的数据放入 Session 里面？</h2><p>答：可以在类上面加上@SessionAttributes 注解,里面包含的字符串就是要放入 session 里面的 key </p><h2 id="20、SpringMvc-怎么和-AJAX-相互调用的？答："><a href="#20、SpringMvc-怎么和-AJAX-相互调用的？答：" class="headerlink" title="20、SpringMvc 怎么和 AJAX 相互调用的？答："></a>20、SpringMvc 怎么和 AJAX 相互调用的？答：</h2><p> 通过 Jackson 框架就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象。  </p><p>  具体步骤如下 ：  </p><p>1）加入 Jackson.jar  </p><p>2）在配置文件中配置 json 的映射   </p><p>3）在接受 Ajax 方法里面可以直接返回 Object,List 等,但方法前面要加上@ResponseBody 注解 </p><p>21、当一个方法向 AJAX 返回特殊对象,譬如 Object,List 等,需要做什么处理？答：要加上@ResponseBody 注解 22、SpringMvc 里面拦截器是怎么写的 </p><p>答：有两种写法,一种是实现接口,另外一种是继承适配器类,然后在 SpringMvc 的配置文件中配置拦截器即可：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置 SpringMvc 的拦截器 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;mvc:interceptors&gt;    </span><br><span class="line"></span><br><span class="line">   &lt;!-- 配置一个拦截器的 Bean 就可以了 默认是对所有请求都拦截 --&gt;    </span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.et.action.MyHandlerInterceptor&quot;&gt;&lt;/bean&gt;      </span><br><span class="line"></span><br><span class="line">   &lt;!-- 只针对部分请求拦截 --&gt;      </span><br><span class="line"></span><br><span class="line">   &lt;mvc:interceptor&gt;       </span><br><span class="line"></span><br><span class="line">​     &lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt;        </span><br><span class="line"></span><br><span class="line">​     &lt;bean class=&quot;com.et.action.MyHandlerInterceptorAdapter&quot; /&gt;  </span><br><span class="line"></span><br><span class="line">   &lt;/mvc:interceptor&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mvc:interceptors&gt; </span><br></pre></td></tr></table></figure><h2 id="23、讲下-SpringMvc-的执行流程"><a href="#23、讲下-SpringMvc-的执行流程" class="headerlink" title="23、讲下 SpringMvc 的执行流程"></a>23、讲下 SpringMvc 的执行流程</h2><p>答：系统启动的时候根据配置文件创建 spring 的容器, 首先是发送 http 请求到核心控制器</p><p>disPatherServlet，spring 容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用</p><p>ModelAndView 进行视图转发，数据放在 model 中，用 map 传递数据进行页面显示。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/SpringCloud%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/SpringCloud%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>问题一：</strong> </p><h1 id="什么是-Spring-Cloud？"><a href="#什么是-Spring-Cloud？" class="headerlink" title="什么是 Spring Cloud？"></a>什么是 Spring Cloud？</h1><p>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成。</p><p>Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。 </p><p><strong>问题二：</strong> </p><h1 id="使用-Spring-Cloud-有什么优势？"><a href="#使用-Spring-Cloud-有什么优势？" class="headerlink" title="使用 Spring Cloud 有什么优势？"></a>使用 Spring Cloud 有什么优势？</h1><p>使用 Spring Boot 开发分布式微服务时，我们面临以下问题 </p><p>•    与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。 </p><p>•    服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。 </p><p>•    冗余-分布式系统中的冗余问题。 </p><p>•    负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。 </p><p>•    性能-问题 由于各种运营开销导致的性能问题。 </p><p>•    部署复杂性-Devops 技能的要求。 </p><p><strong>问题三：</strong> </p><h1 id="服务注册和发现是什么意思？Spring-Cloud-如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud-如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud 如何实现？"></a>服务注册和发现是什么意思？Spring Cloud 如何实现？</h1><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。 </p><h1 id="问题四：负载平衡的意义什么？"><a href="#问题四：负载平衡的意义什么？" class="headerlink" title="问题四：负载平衡的意义什么？"></a>问题四：负载平衡的意义什么？</h1><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。 </p><h1 id="问题五：什么是-Hystrix？它如何实现容错？"><a href="#问题五：什么是-Hystrix？它如何实现容错？" class="headerlink" title="问题五：什么是 Hystrix？它如何实现容错？"></a><strong>问题五：什么是 Hystrix？它如何实现容错？</strong></h1><p>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。 </p><p>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。  </p><p>思考以下微服务 </p><p><img src="/SpringCloud%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.assets/1.jpg" alt="1"></p><p>假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。 </p><p>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000.这是 hystrix 出现的地方我们将使用 Hystrix 在这种情况下的 Fallback 方法功能。我们有两个服务 employee-consumer 使用由 employee-consumer 公开的服务。  </p><p>简化图如下所示  </p><p><img src="/SpringCloud%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.assets/2.jpg" alt="2"></p><p>现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在这种情况下使用 Hystrix</p><p>定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。 </p><h1 id="问题六：-什么是Hystrix-断路器？我们需要它吗？"><a href="#问题六：-什么是Hystrix-断路器？我们需要它吗？" class="headerlink" title="问题六： 什么是Hystrix 断路器？我们需要它吗？"></a>问题六： 什么是Hystrix 断路器？我们需要它吗？</h1><p>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用 Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。 </p><p><img src="/SpringCloud%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.assets/3.jpg" alt="3"></p><p>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工使用者将一起跳过</p><p>firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。 </p><p><img src="/SpringCloud%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.assets/4.jpg" alt="4"></p><h1 id="问题-七："><a href="#问题-七：" class="headerlink" title="问题****七："></a><strong>问题****七：</strong></h1><h1 id="什么是-Netflix-Feign？它的优点是什么？"><a href="#什么是-Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是 Netflix Feign？它的优点是什么？"></a><strong>什么是</strong> <strong>Netflix Feign？它的优点是什么？</strong></h1><p>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST 模板公开的 REST 服务。</p><p>但是我们必须编写大量代码才能执行以下步骤</p><p>·   使用功能区进行负载平衡。 </p><p>·   获取服务实例，然后获取基本 URL。 </p><p>·   利用 REST 模板来使用服务。 前面的代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.  @Controller</span><br><span class="line">2.  public class ConsumerControllerClient &#123; 3.</span><br><span class="line">4.  @Autowired</span><br><span class="line">5.  private LoadBalancerClient loadBalancer; 6.</span><br><span class="line">7.  public void getEmployee() throws RestClientException, IOException &#123; </span><br><span class="line">8.</span><br><span class="line">9.ServiceInstance serviceInstance=loadBalancer.choose(&quot;employee-producer&quot;); </span><br><span class="line">10.</span><br><span class="line">11.System.out.println(serviceInstance.getUri()); </span><br><span class="line">12.</span><br><span class="line">13.String baseUrl=serviceInstance.getUri().toString(); </span><br><span class="line">14.</span><br><span class="line">15.baseUrl=baseUrl+&quot;/employee&quot;; </span><br><span class="line">16.</span><br><span class="line">17.RestTemplate restTemplate = new RestTemplate(); </span><br><span class="line">18.ResponseEntity&lt;String&gt; response=null; </span><br><span class="line">19.try&#123; </span><br><span class="line">20.response=restTemplate.exchange(baseUrl, </span><br><span class="line">21.HttpMethod.GET, getHeaders(),String.class); </span><br><span class="line">22.&#125;catch (Exception ex) </span><br><span class="line">23.&#123;</span><br><span class="line">24.System.out.println(ex);</span><br><span class="line">25.&#125;</span><br><span class="line">26.System.out.println(response.getBody());</span><br><span class="line">27. &#125;</span><br></pre></td></tr></table></figure><p>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如何使用 Netflix Feign使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。</p><h1 id="问题-八："><a href="#问题-八：" class="headerlink" title="问题****八："></a><strong>问题****八：</strong></h1><h1 id="什么是-Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是-Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是 Spring Cloud Bus？我们需要它吗？"></a><strong>什么是</strong> <strong>Spring Cloud Bus？我们需要它吗？</strong></h1><p> 考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而 Spring Cloud Config 从GIT 读取这些属性。 </p><p>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。</p><p><img src="/SpringCloud%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.assets/5.jpg" alt="5"></p><p>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。 </p><p>还有另一种使用执行器端点&#x2F;刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果</p><p>Employee Producer1 部署在端口 8080 上，则调用 http：&#x2F;&#x2F; localhost：8080 &#x2F; refresh。同样对于 Employee Producer2 http：&#x2F;&#x2F; localhost：8081 &#x2F; refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。  </p><p> <img src="/SpringCloud%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.assets/6.jpg" alt="6"></p><p>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点&#x2F;总线&#x2F;刷新来实现对任何单个实例的刷新。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/SpringBoot%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/SpringBoot%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>什么是 Spring Boot？ </p><p>多年来，随着新功能的增加，spring 变得越来越复杂。只需访问 <a href="https://spring.io/projects">https://spring.io/projects</a></p><p>页面，我们就会看到可以在我们的应用程序中使用的所有 Spring 项目的不同功能。如果必须启动一个新的 Spring 项目，我们必须添加构建路径或添加 Maven 依赖关系，配置应用程序服务器，添加 spring 配置。因此，开始一个新的 spring 项目需要很多努力，因为我们现在必须从头开始做所有事情。 </p><p>Spring   Boot 是解决这个问题的方法。Spring     Boot 已经建立在现有 spring 框架之上。使用 spring 启动，我们避免了之前我们必须做的所有样板代码和配置。因此，Spring  Boot 可以帮助我们以最少的工作量，更加健壮地使用现有的 Spring 功能。 </p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>Spring Boot 有哪些优点？ </p><p>Spring Boot 的优点有： </p><p>减少开发，测试时间和努力。 </p><p>使用 JavaConfig 有助于避免使用 XML。 </p><p>避免大量的 Maven 导入和各种版本冲突。 </p><p>提供意见发展方法。 </p><p>通过提供默认值快速开始开发。 </p><p>没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish 或其他任何东西。 </p><p>需要更少的配置 因为没有 web.xml 文件。只需添加用@ Configuration 注释的类，然后添加用@Bean 注释的方法，Spring 将自动加载对象并像以前一样对其进行管理。您甚至可以将</p><p>@Autowired 添加到 bean 方法中，以使 Spring 自动装入需要的依赖关系中。 </p><p>基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：Dspring.profiles.active &#x3D; {enviornment}。在加载主应用程序属性文件后，Spring 将在</p><p>（application{environment} .properties）中加载后续的应用程序属性文件。 </p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>什么是 JavaConfig？ </p><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯 Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于： </p><p>面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。 </p><p>减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将 JavaConfig 与 XML 混合匹配是理想的。 </p><p>类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring 容器。由于</p><p>Java     5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。 </p><h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2><p>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？ </p><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式 tomcat</p><p>将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。</p><p>它还提供 H2 数据库控制台以更好地测试应用程序。 </p><p>org.springframework.boot spring-boot-devtools true </p><h2 id="问题五"><a href="#问题五" class="headerlink" title="问题五"></a>问题五</h2><p>Spring Boot 中的监视器是什么？ </p><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的 REST 端点来检查状态。 </p><h2 id="问题六"><a href="#问题六" class="headerlink" title="问题六"></a>问题六</h2><p>如何在 Spring Boot 中禁用 Actuator 端点安全性？ </p><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访</p><p>问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用 </p><p>management.security.enabled &#x3D; false </p><p>来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。 </p><h2 id="问题七"><a href="#问题七" class="headerlink" title="问题七"></a>问题七</h2><p>如何在自定义端口上运行 Spring Boot 应用程序？ </p><p>为了在自定义端口上运行 Spring     Boot 应用程序，您可以在 application.properties 中指定端口。 </p><p>server.port &#x3D; 8090 </p><h2 id="问题八"><a href="#问题八" class="headerlink" title="问题八"></a>问题八</h2><p>什么是 YAML？ </p><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。 </p><p>与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。 </p><h2 id="问题九"><a href="#问题九" class="headerlink" title="问题九"></a>问题九</h2><p>如何实现 Spring Boot 应用程序的安全性？ </p><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展 WebSecurityConfigurerAdapter 并覆盖其方法。 </p><h2 id="问题十"><a href="#问题十" class="headerlink" title="问题十"></a>问题十</h2><p>如何集成 Spring Boot 和 ActiveMQ？ </p><p>对于集成 Spring Boot 和 ActiveMQ，我们使用 </p><p>spring-boot-starter-activemq 依赖关系。 它只需要很少的配置，并且不需要样板代码。 </p><h2 id="问题十一"><a href="#问题十一" class="headerlink" title="问题十一"></a>问题十一</h2><p>如何使用 Spring Boot 实现分页和排序？ </p><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的 </p><p>org.springframework.data.domain.Pageable 传递给存储库方法。 </p><h2 id="问题十二"><a href="#问题十二" class="headerlink" title="问题十二"></a>问题十二</h2><p>什么是 Swagger？你用 Spring Boot 实现了它吗？ </p><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful     Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻</p><p>辑来理解远程服务并与其进行交互。因此，Swagger 消除了调用服务时的猜测。 </p><h2 id="问题十三"><a href="#问题十三" class="headerlink" title="问题十三"></a>问题十三</h2><p>什么是 Spring Profiles？ </p><p>Spring   Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION 中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。 </p><h2 id="问题十四"><a href="#问题十四" class="headerlink" title="问题十四"></a>问题十四</h2><p>什么是 Spring Batch？ </p><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单</p><p>以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。 </p><h2 id="问题十五"><a href="#问题十五" class="headerlink" title="问题十五"></a>问题十五</h2><p>什么是 FreeMarker 模板？ </p><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用 freemarker 可以将这些结合起来，给出最终的输出页面。 </p><h2 id="问题十六"><a href="#问题十六" class="headerlink" title="问题十六"></a>问题十六</h2><p>如何使用 Spring Boot 实现异常处理？ </p><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个</p><p>ControlerAdvice 类，来处理控制器类抛出的所有异常。 </p><h2 id="问题十七"><a href="#问题十七" class="headerlink" title="问题十七"></a>问题十七</h2><p>您使用了哪些 starter maven 依赖项？ </p><p>使用了下面的一些依赖项 </p><p>spring-boot-starter-activemq spring-boot-starter-security</p><p>spring-boot-starter-web </p><p>这有助于增加更少的依赖关系，并减少版本的冲突。 </p><h2 id="问题十八"><a href="#问题十八" class="headerlink" title="问题十八"></a>问题十八</h2><p>什么是 CSRF 攻击？ </p><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的 Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。 </p><h2 id="问题十九"><a href="#问题十九" class="headerlink" title="问题十九"></a>问题十九</h2><p>什么是 WebSockets？ </p><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。 </p><p>WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。 </p><p>WebSocket 是全双工的 -客户端和服务器通信是相互独立的。 </p><p>单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信 </p><p>Light -与 http 相比，WebSocket 消息数据交换要轻得多。 </p><h2 id="问题二十"><a href="#问题二十" class="headerlink" title="问题二十"></a>问题二十</h2><p>什么是 AOP？ </p><p>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题。这些交叉问题与应用程序的主要业务逻辑不同。因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。 </p><h2 id="问题二十一"><a href="#问题二十一" class="headerlink" title="问题二十一"></a>问题二十一</h2><p>什么是 Apache Kafka？ </p><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。 </p><h2 id="问题二十二"><a href="#问题二十二" class="headerlink" title="问题二十二"></a>问题二十二</h2><p>我们如何监视所有 Spring Boot 微服务？ </p><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/Netty%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/Netty%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-BIO、NIO-和-AIO-的区别？"><a href="#1-BIO、NIO-和-AIO-的区别？" class="headerlink" title="1.BIO、NIO 和 AIO 的区别？"></a>1.BIO、NIO 和 AIO 的区别？</h2><p>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。 </p><p>伪异步 IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。 </p><p>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求时才启动一个线程进行处理。 </p><p>AIO：一个有效请求一个线程，客户端的 I&#x2F;O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理， </p><p>BIO 是面向流的，NIO 是面向缓冲区的；BIO 的各种流是阻塞的。而 NIO 是非阻塞的；BIO 的 Stream 是单向的，而 NIO 的 channel 是双向的。 </p><p>NIO 的特点：事件驱动模型、单线程处理多任务、非阻塞 I&#x2F;O，I&#x2F;O 读写不再阻塞，而是返回 0、基于 block 的传输比基于流的传输更高效、更高级的 IO 函数 zero-copy、IO 多路复用大大提高了 Java 网络应用的可伸缩性和实用性。基于 Reactor 线程模型。 </p><p>在 Reactor 模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如在 Reactor 中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。 </p><h2 id="2-NIO-的组成？"><a href="#2-NIO-的组成？" class="headerlink" title="2.NIO 的组成？"></a>2.NIO 的组成？</h2><p>Buffer：与 Channel 进行交互，数据是从 Channel 读入缓冲区，从缓冲区写入 Channel 中的 </p><p>flip 方法 ： 反转此缓冲区，将 position 给 limit，然后将 position 置为 0，其实就是切换读写模式 </p><p>clear 方法 ：清除此缓冲区，将 position 置为 0，把 capacity 的值给 limit。 </p><p>rewind 方法 ： 重绕此缓冲区，将 position 置为 0 </p><p>DirectByteBuffer 可减少一次系统空间到用户空间的拷贝。但 Buffer 创建和销毁的成本更</p><p>高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机 I&#x2F;O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用 heapBuffer，由 JVM 进行管理。 </p><p>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与 Buffer 进行交互。通过源码可知，FileChannel 的 read 方法和 write 方法都导致数据复制了两次！ </p><p>Selector 可使一个单独的线程管理多个 Channel，open 方法可创建 Selector，register 方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产</p><p>生一个 SelectionKey：它表示 SelectableChannel 和 Selector 之间的注册关系，wakeup 方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的 channel 或者事件；channel 关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。 </p><p>Selector 在 Linux 的实现类是 EPollSelectorImpl，委托给 EPollArrayWrapper 实现，其中三个 native 方法是对 epoll 的封装，而 EPollSelectorImpl.   implRegister 方法，通过调用 epoll_ctl 向 epoll 实例中注册事件，还将注册的文件描述符(fd)与 SelectionKey 的对应关系添加到 fdToKey 中，这个 map 维护了文件描述符与 SelectionKey 的映射。 </p><p>fdToKey 有时会变得非常大，因为注册到 Selector 上的 Channel 非常多（百万连接）；过期或失效的 Channel 没有及时关闭。fdToKey 总是串行读取的，而读取是在 select 方法中进行的，该方法是非线程安全的。 </p><p>Pipe：两个线程之间的单向数据连接，数据会被写到 sink 通道，从 source 通道读取 </p><p>NIO 的服务端建立过程：Selector.open()：打开一个 Selector；ServerSocketChannel.open()：创建服务端的 Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册</p><p>Channel 和关注的事件到 Selector 上；select()轮询拿到已经就绪的事件 </p><h2 id="3-Netty-的特点？"><a href="#3-Netty-的特点？" class="headerlink" title="3.Netty 的特点？"></a>3.Netty 的特点？</h2><p>一个高性能、异步事件驱动的 NIO 框架，它提供了对 TCP、UDP 和文件传输的支持使用更高效的 socket 底层，对 epoll 空轮询引起的 cpu 占用飙升在内部进行了处理，避免了直接使用 NIO 的陷阱，简化了 NIO 的处理方式。 </p><p>采用多种 decoder&#x2F;encoder 支持，对 TCP 粘包&#x2F;分包进行自动化处理 </p><p>可使用接受&#x2F;处理线程池，提高连接效率，对重连、心跳检测的简单支持 </p><p>可配置 IO 线程数、TCP 参数， TCP 接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用 ByteBuf </p><p>通过引用计数器及时申请释放不再引用的对象，降低了 GC 频率使用单线程串行化的方式，高效的 Reactor 线程模型大量使用了 volitale、使用了 CAS 和原子类、线程安全类的使用、读写锁的使用 </p><h2 id="4-Netty-的线程模型？"><a href="#4-Netty-的线程模型？" class="headerlink" title="4.Netty 的线程模型？"></a>4.Netty 的线程模型？</h2><p>Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，</p><p>boss 线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work</p><p>线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。 </p><p>单线程模型：所有 I&#x2F;O 操作都由一个线程完成，即多路复用、事件分发和处理都是在一个 Reactor 线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送&#x2F;读取请求或应答&#x2F;响应消息。一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，速度</p><p>慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。 </p><p>多线程模型：有一个 NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请求；NIO 线程池负责网络 IO 的操作，即消息的读取、解码、编码和发送；1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个 Acceptor 线程可能会存在性能不足问题。 </p><p>主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从主线程池的 Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上，用于处理 I&#x2F;O 的读写等操作，从而保证 mainReactor 只负责接入认证、握手等操作； </p><h2 id="5-TCP-粘包-x2F-拆包的原因及解决方法？"><a href="#5-TCP-粘包-x2F-拆包的原因及解决方法？" class="headerlink" title="5.TCP 粘包&#x2F;拆包的原因及解决方法？"></a>5.TCP 粘包&#x2F;拆包的原因及解决方法？</h2><p>TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。 </p><p>TCP 粘包&#x2F;分包的原因： </p><p>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；进行 MSS 大小的 TCP 分段，当 TCP 报文长度-TCP 头部长度&gt;MSS 的时候将发生拆包以太网帧的 payload（净荷）大于 MTU（1500 字节）进行 ip 分片。 </p><p>解决方法 </p><p>消息定长：FixedLengthFrameDecoder 类 </p><p>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder 或自定义分隔符类 ：</p><p>DelimiterBasedFrameDecoder </p><p>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。 </p><h2 id="6-了解哪几种序列化协议？"><a href="#6-了解哪几种序列化协议？" class="headerlink" title="6.了解哪几种序列化协议？"></a>6.了解哪几种序列化协议？</h2><p>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。 </p><p>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能</p><p>（CPU 资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。 </p><p>Java 默认提供的序列化：无法跨语言、序列化后的码流太大、序列化的性能差 </p><p>XML，优点：人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。 </p><p>JSON，是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与 XML 相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比 XML 差、不适合性能要求为 ms 级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于 Web </p><p>browser 的 Ajax 请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。 </p><p>Fastjson，采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前 java 语言中最快的 json 库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web 输出、Android 客户端 Thrift，不仅是序列化协议，还是一个 RPC 框架。优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如 HTTP）、无法支持向持久层直接读写数据，即</p><p>不适合做数据持久化序列化协议。适用场景：分布式系统的 RPC 解决方案 </p><p>Avro，Hadoop 的一个子项目，解决了 JSON 的冗长和没有 IDL 的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用 RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在 Hadoop 中做 Hive、Pig 和 MapReduce 的持久化数据格式。 </p><p>Protobuf，将数据结构以.proto 文件进行描述，通过代码生成工具可以生成对应数据结构的 POJO 对象和 Protobuf 相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON 等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持</p><p>Java 、C++ 、python。适用场景：对性能要求高的 RPC 调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化 </p><p>其它 </p><p>protostuff 基于 protobuf 协议，但不需要配置 proto 文件，直接导包即可 </p><p>Jboss marshaling 可以直接序列化 java 类， 无须实 java.io.Serializable 接口 </p><p>Message pack 一个高效的二进制序列化格式 </p><p>Hessian 采用二进制协议的轻量级 remoting onhttp 工具 </p><p>kryo         基于 protobuf 协议，只支持 java 语言,需要注册（Registration），然后序列化</p><p>（Output），反序列化（Input） </p><h2 id="7-如何选择序列化协议？"><a href="#7-如何选择序列化协议？" class="headerlink" title="7.如何选择序列化协议？"></a>7.如何选择序列化协议？</h2><p>具体场景 </p><p>对于公司间的系统调用，如果性能要求在 100ms 以上的服务，基于 XML 的 SOAP 协议是一个值得考虑的方案。 </p><p>基于 Web browser 的 Ajax，以及 Mobile app 与服务端之间的通讯，JSON 协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON 也是非常不错的选择。 </p><p>对于调试环境比较恶劣的场景，采用 JSON 或 XML 能够极大的提高调试效率，降低系统开发成本。 </p><p>当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro 之间具有一定的竞争关系。对于 T 级别的数据的持久化应用场景，Protobuf 和 Avro 是首要选择。如果持久化后的数据存储在 hadoop 子项目里，Avro 会是更好的选择。 </p><p>对于持久层非 Hadoop 项目，以静态类型语言为主的应用场景，Protobuf 会更符合静态类型语言工程师的开发习惯。由于 Avro 的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro 是更好的选择。 </p><p>如果需要提供一个完整的 RPC 解决方案，Thrift 是一个好的选择。 </p><p>如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，</p><p>Protobuf 可以优先考虑。 </p><p>protobuf 的数据类型有多种：bool、double、float、int32、int64、string、bytes、enum、 message。protobuf 的限定符：required: 必须赋值，不能为空、optional:字段可以赋值，也可以不赋值、repeated: 该字段可以重复任意次数（包括 0 次）、枚举；只能用指定的常量集中的一个值作为其值； </p><p>protobuf 的基本规则：每个消息中必须至少留有一个 required 类型的字段、包含 0 个或多个 optional 类型的字段；repeated 表示的字段可以包含 0 个或多个数据；[1,15]之内的标识号在编码的时候会占用一个字节（常用），[16,2047]之内的标识号则占用 2 个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。 </p><p>protobuf 的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的 required 字段，optional 和 repeated 类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是 optional 或 repeated。因为旧版本程序无法读取或写入新增的 required 限定符的字段。 </p><p>编译器为每一个消息类型生成了一个.java 文件，以及一个特殊的 Builder 类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder &#x3D; </p><p>UserProto.User.newBuilder();builder.build()； </p><p>Netty 中的使用：ProtobufVarint32FrameDecoder          是用于处理半包消息的解码类；</p><p>ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的 UserProto.java 文件中的解码类；ProtobufVarint32LengthFieldPrepender 对 protobuf 协议的消息头上加上一个长度为</p><p>32 的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类 </p><p>将 StringBuilder 转换为 ByteBuf 类型：copiedBuffer()方法 </p><h2 id="8-Netty-的零拷贝实现？"><a href="#8-Netty-的零拷贝实现？" class="headerlink" title="8.Netty 的零拷贝实现？"></a>8.Netty 的零拷贝实现？</h2><p>Netty 的接收和发送 ByteBuffer 采用 DIRECT  BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM 会将堆内存</p><p>Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。ByteBuffer 由 ChannelConfig 分配，</p><p>而 ChannelConfig 创建 ByteBufAllocator 默认使用 Direct Buffer </p><p>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。addComponents 方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在 CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体 </p><p>通过 FileRegion 包装的 FileChannel.tranferTo 方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。 </p><p>通过   wrap 方法, 我们可以将   byte[] 数组、ByteBuf、ByteBuffer 等包装成一个   Netty </p><p>ByteBuf 对象, 进而避免了拷贝操作。 </p><p>Selector  BUG：若 Selector 的轮询结果为空，也没有 wakeup 或新消息处理，则发生空轮询，CPU 使用率 100%， </p><p>Netty 的解决办法：对 Selector 的 select 操作周期进行统计，每完成一次空的 select 操作进行一次计数，若在某个周期内连续发生 N 次空轮询，则触发了 epoll 死循环 bug。重建</p><p>Selector，判断是否是其他线程发起的重建请求，若不是则将原 SocketChannel 从旧的</p><p>Selector 上去除注册，重新注册到新的 Selector 上，并将原来的 Selector 关闭。 </p><h2 id="9-Netty-的高性能表现在哪些方面？"><a href="#9-Netty-的高性能表现在哪些方面？" class="headerlink" title="9.Netty 的高性能表现在哪些方面？"></a>9.Netty 的高性能表现在哪些方面？</h2><p>心跳，对服务端：会定时清除闲置会话 inactive(netty5)，对客户端:用来检测会话是否断</p><p>开，是否重来，检测网络延迟，其中 idleStateHandler 类 用来检测会话状态 </p><p>串行无锁化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，</p><p>这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。 </p><p>可靠性，链路有效性检测：链路空闲检测机制，读&#x2F;写空闲超时机制；内存保护机制：通过内存池重用 ByteBuf;ByteBuf 的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。 </p><p>Netty 安全性：支持的安全协议：SSL V2 和 V3，TLS，SSL 单向认证、双向认证和第三方 CA 认证。 </p><p>高效并发编程的体现：volatile 的大量、正确使用；CAS 和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。IO 通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程） </p><p>流量整型的作用（变压器）：防止由于上下游网元性能不均衡导致下游网元被压垮，业务</p><p>流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。 </p><p>TCP 参数配置：SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K；</p><p>SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法； </p><h2 id="10-NIOEventLoopGroup-源码？"><a href="#10-NIOEventLoopGroup-源码？" class="headerlink" title="10.NIOEventLoopGroup 源码？"></a>10.NIOEventLoopGroup 源码？</h2><p>NioEventLoopGroup(其实是 MultithreadEventExecutorGroup)           内部维护一个类型为 </p><p>EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化 EventExecutor 时 NioEventLoopGroup 重载 newChild 方法，所以 children 元素的实际类型为</p><p>NioEventLoop。 </p><p>线程启动时调用 SingleThreadEventExecutor 的构造方法，执行 NioEventLoop 类的 run 方法，首先会调用 hasTasks()方法判断当前 taskQueue 是否有元素。如果 taskQueue 中有元素，执行 selectNow() 方法，最终执行 selector.selectNow()，该方法会立即返回。如果 taskQueue 没有元素，执行 select(oldWakenUp) 方法 </p><p>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录 selector.select 方法的执行次数和标识是否执行过 selector.selectNow()，若触发了 epoll 的空轮询 bug，则会反复</p><p>执行 selector.select(timeoutMillis)，变量 selectCnt 会逐渐变大，当 selectCnt 达到阈值（默认 512），则执行 rebuildSelector 方法，进行 selector 重建，解决 cpu 占用 100%的 bug。 </p><p>rebuildSelector 方法先通过 openSelector 方法创建一个新的 selector。然后将 old selector 的 selectionKey 执行 cancel。最后将 old     selector 的 channel 重新注册到新的 selector 中。 rebuild 后，需要重新执行方法 selectNow，检查是否有已 ready 的 selectionKey。 </p><p>接下来调用 processSelectedKeys 方法（处理 I&#x2F;O 任务），当 selectedKeys !&#x3D; null 时，调用 processSelectedKeysOptimized 方法，迭代 selectedKeys 获取就绪的 IO 事件的 selectkey 存放在数组 selectedKeys 中, 然后为每个事件都调用 processSelectedKey 来处理它， processSelectedKey 中分别处理 OP_READ；OP_WRITE；OP_CONNECT 事件。 </p><p>最后调用 runAllTasks 方法（非 IO 任务），该方法首先会调用 fetchFromScheduledTaskQueue 方法，把 scheduledTaskQueue 中已经超过延迟执行时间的任务移到 taskQueue 中等待被执行，然后依次从 taskQueue 中取任务执行，每执行 64 个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非 IO 任务，避免非 IO 任务太多，影响 IO 任务的执行。 </p><p>每个 NioEventLoop 对应一个线程和一个 Selector，NioServerSocketChannel 会主动注册到某一个 NioEventLoop 的 Selector 上，NioEventLoop 负责事件轮询。 </p><p>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail 到 head。Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。 </p><p>内存管理机制，首先会预申请一大块内存 Arena，Arena 由许多 Chunk 组成，而每个 Chunk 默认由 2048 个 page 组成。Chunk 通过 AVL 树的形式组织 Page，每个叶子节点表示一个 Page，而中间节点表示内存区域，节点自己记录它在整个 Arena 中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于 8k 的内存分配在 poolChunkList 中，而 PoolSubpage 用于分配小于 8k 的内存，它会把一个 page 分割成多段，进行内存分配。 </p><p>ByteBuf 的特点：支持自动扩容（4M），保证 put 方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）；不需要调用 flip()来切换读&#x2F;写模式，读取和写入索引分开；方法链；引用计数基于 AtomicIntegerFieldUpdater 用于内存回收；PooledByteBuf 采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。UnpooledHeapByteBuf 每次都会新建一个缓冲区对象。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"/>
      <url>/2022/04/27/Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-Kafka-的设计时什么样的呢？"><a href="#1-Kafka-的设计时什么样的呢？" class="headerlink" title="1.Kafka 的设计时什么样的呢？"></a>1.Kafka 的设计时什么样的呢？</h1><p>Kafka 将消息以 topic 为单位进行归纳</p><p>将向 Kafka topic 发布消息的程序成为 producers.</p><p>将预订 topics 并消费消息的程序成为 consumer.</p><p>Kafka 以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 broker. </p><p>producers 通过网络将消息发送到 Kafka 集群，集群向消费者提供消息</p><h1 id="2-数据传输的事物定义有哪三种？"><a href="#2-数据传输的事物定义有哪三种？" class="headerlink" title="2.数据传输的事物定义有哪三种？"></a>2.数据传输的事物定义有哪三种？</h1><p>数据传输的事务定义通常有以下三种级别：</p><p>（1）最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输</p><p>（2）最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.</p><p>（3）精确的一次（Exactly once）:不会漏传输也不会重复传输,每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的</p><h1 id="3-Kafka-判断一个节点是否还活着有那两个条件？"><a href="#3-Kafka-判断一个节点是否还活着有那两个条件？" class="headerlink" title="3.Kafka 判断一个节点是否还活着有那两个条件？"></a>3.Kafka 判断一个节点是否还活着有那两个条件？</h1><p>（1）节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接</p><p>（2）如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太久</p><h1 id="4-producer-是否直接将数据发送到-broker-的-leader-主节点-？"><a href="#4-producer-是否直接将数据发送到-broker-的-leader-主节点-？" class="headerlink" title="4.producer 是否直接将数据发送到 broker 的 leader(主节点)？"></a>4.producer 是否直接将数据发送到 broker 的 leader(主节点)？</h1><p>producer 直接将数据发送到 broker 的 leader(主节点)，不需要在多个节点进行分发，为了帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知:哪些节点是活动的，目标topic 目标分区的 leader 在哪。这样 producer 就可以直接将消息发送到目的地了</p><h1 id="5、Kafa-consumer-是否可以消费指定分区消息？"><a href="#5、Kafa-consumer-是否可以消费指定分区消息？" class="headerlink" title="5、Kafa consumer 是否可以消费指定分区消息？"></a>5、Kafa consumer 是否可以消费指定分区消息？</h1><p>Kafaconsumer 消费消息时，向 broker 发出”fetch”请求去消费特定分区的消息，consumer 指定消息在日志中的偏移量（offset），就可以消费从这个位置开始的消息，customer 拥有了 offset 的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的</p><h1 id="6、Kafka-消息是采用-Pull-模式，还是-Push-模式？"><a href="#6、Kafka-消息是采用-Pull-模式，还是-Push-模式？" class="headerlink" title="6、Kafka 消息是采用 Pull 模式，还是 Push 模式？"></a>6、Kafka 消息是采用 Pull 模式，还是 Push 模式？</h1><p>Kafka 最初考虑的问题是，customer 应该从 brokes 拉取消息还是 brokers 将消息推送到</p><p>consumer，也就是 pull 还 push。在这方面，Kafka 遵循了一种大部分消息系统共同的传统的设计：producer 将消息推送到 broker，consumer 从 broker 拉取消息</p><p>一些消息系统比如 Scribe 和 ApacheFlume 采用了 push 模式，将消息推送到下游的 consumer。这样做有好处也有坏处：由 broker 决定消息推送的速率，对于不同消费速率的 consumer 就不太好处理了。消息系统都致力于让 consumer 以最大的速率最快速的消费消息，但不幸的是，push 模式下，当 broker 推送的速率远大于 consumer 消费的速率时， consumer 恐怕就要崩溃了。最终 Kafka 还是选取了传统的 pull 模式</p><p>Pull 模式的另外一个好处是 consumer 可以自主决定是否批量的从 broker 拉取数据。Push 模式必须在不知道下游 consumer 消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免 consumer 崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull 模式下，consumer 就可以根据自己的消费能力去决定这些策略</p><p>Pull 有个缺点是，如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询， </p><p>直到新消息到 t 达。为了避免这点，Kafka 有个参数可以让 consumer 阻塞知道新消息到达</p><p>(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发</p><h1 id="7-Kafka-存储在硬盘上的消息格式是什么？"><a href="#7-Kafka-存储在硬盘上的消息格式是什么？" class="headerlink" title="7.Kafka 存储在硬盘上的消息格式是什么？"></a>7.Kafka 存储在硬盘上的消息格式是什么？</h1><p>消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和 CRC32</p><p>校验码。</p><p>·消息长度: 4 bytes (value: 1+4+n)</p><p>·版本号: 1 byte</p><p>·CRC 校验码: 4 bytes</p><p>·具体的消息: n bytes</p><h1 id="8-Kafka-高效文件存储设计特点："><a href="#8-Kafka-高效文件存储设计特点：" class="headerlink" title="8.Kafka 高效文件存储设计特点："></a>8.Kafka 高效文件存储设计特点：</h1><p>(1).Kafka 把 topic 中一个 parition 大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</p><p>(2).通过索引信息可以快速定位 message 和确定 response 的最大大小。</p><p>(3).通过 index 元数据全部映射到 memory，可以避免 segment file 的 IO 磁盘操作。(4).通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小。</p><h1 id="9-Kafka-与传统消息系统之间有三个关键区别"><a href="#9-Kafka-与传统消息系统之间有三个关键区别" class="headerlink" title="9.Kafka 与传统消息系统之间有三个关键区别"></a>9.Kafka 与传统消息系统之间有三个关键区别</h1><p>(1).Kafka 持久化日志，这些日志可以被重复读取和无限期保留</p><p>(2).Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性</p><p>(3).Kafka 支持实时的流式处理</p><h1 id="10-Kafka-创建-Topic-时如何将分区放置到不同的-Broker-中"><a href="#10-Kafka-创建-Topic-时如何将分区放置到不同的-Broker-中" class="headerlink" title="10.Kafka 创建 Topic 时如何将分区放置到不同的 Broker 中"></a>10.Kafka 创建 Topic 时如何将分区放置到不同的 Broker 中</h1><p>·副本因子不能大于 Broker 的个数；</p><p>·第一个分区（编号为 0）的第一个副本放置位置是随机从 brokerList 选择的；</p><p>·其他分区的第一个副本放置位置相对于第 0 个分区依次往后移。也就是如果我们有 5 个</p><p>Broker，5 个分区，假设第一个分区放在第四个 Broker 上，那么第二个分区将会放在第五个</p><p>Broker上；第三个分区将会放在第一个Broker上；第四个分区将会放在第二个Broker 上，依次类推；</p><p>·剩余的副本相对于第一个副本放置位置其实是由 nextReplicaShift 决定的，而这个数也是随机产生的</p><h1 id="11-Kafka-新建的分区会在哪个目录下创建"><a href="#11-Kafka-新建的分区会在哪个目录下创建" class="headerlink" title="11.Kafka 新建的分区会在哪个目录下创建"></a>11.Kafka 新建的分区会在哪个目录下创建</h1><p>在启动 Kafka 集群之前，我们需要配置好 log.dirs 参数，其值是 Kafka 数据的存放目录， 这个参数可以配置多个目录，目录之间使用逗号分隔，通常这些目录是分布在不同的磁盘上用于提高读写性能。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/JVM%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/JVM%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-内存模型以及分区，需要详细到每个区放什么。"><a href="#1-内存模型以及分区，需要详细到每个区放什么。" class="headerlink" title="1. 内存模型以及分区，需要详细到每个区放什么。"></a>1. 内存模型以及分区，需要详细到每个区放什么。</h2><p>JVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面，</p><p>class 类信息常量池（static 常量和 static 变量）等放在方法区new:</p><p>·   方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字</p><p>节码）等数据</p><p>·   堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要</p><p>在堆上分配</p><p>·   栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操</p><p>作数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类型，所以还是一个指向地址的指针</p><p>·   本地方法栈：主要为 Native 方法服务</p><p>·   程序计数器：记录当前线程执行的行号</p><h2 id="2-堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。"><a href="#2-堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。" class="headerlink" title="2. 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。"></a>2. 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。</h2><p>堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），新生代包含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区</p><p>当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice</p><p>区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎</p><p>片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。</p><h2 id="3-对象创建方法，对象的内存分配，对象的访问定位。"><a href="#3-对象创建方法，对象的内存分配，对象的访问定位。" class="headerlink" title="3.  对象创建方法，对象的内存分配，对象的访问定位。"></a>3.  对象创建方法，对象的内存分配，对象的访问定位。</h2><p>new 一个对象</p><h2 id="4-GC-的两种判定方法："><a href="#4-GC-的两种判定方法：" class="headerlink" title="4.  GC 的两种判定方法："></a>4.  GC 的两种判定方法：</h2><p>引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）的情况</p><p>引用链法： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，如果有一条链能够到达 GC ROOT 就说明，不能到达 GC ROOT 就说明可以回收</p><h2 id="5-SafePoint-是什么"><a href="#5-SafePoint-是什么" class="headerlink" title="5.  SafePoint 是什么"></a>5.  SafePoint 是什么</h2><p>比如 GC 的时候必须要等到 <a href="http://lib.csdn.net/base/java">Java</a> 线程都进入到 safepoint 的时候 VMThread 才能开始</p><p>执行 GC，</p><ol><li>循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入</li></ol><p>safepoint)</p><ol start="2"><li><p>方法返回前</p></li><li><p>调用方法的 call 之后</p></li><li><p>抛出异常的位置</p></li></ol><h2 id="6-GC-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"><a href="#6-GC-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" class="headerlink" title="6. GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"></a>6. GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</h2><p>先标记，标记完毕之后再清除，效率不高，会产生碎片</p><p>复制算法：分为 8：1 的 Eden 区和 survivor 区，就是上面谈到的 YGC</p><p>标记整理：标记完毕之后，让所有存活的对象向一端移动</p><h2 id="7-GC-收集器有哪些？CMS-收集器与-G1-收集器的特点。"><a href="#7-GC-收集器有哪些？CMS-收集器与-G1-收集器的特点。" class="headerlink" title="7.  GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。"></a>7.  GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。</h2><p>并行收集器：串行收集器使用一个单独的线程进行收集，GC 时服务有停顿时间串行收集器：次要回收中使用多线程来执行</p><p>CMS 收集器是基于<strong>“标记—清除”</strong>算法实现的，经过多次标记才会被清除</p><p>G1 从<strong>整体来看是基于“标记—整理”</strong>算法实现的收集器，从<strong>局部（两个</strong> <strong>Region</strong> <strong>之间）</strong></p><p><strong>上来看是基于“复制”</strong>算法实现的</p><h2 id="8-Minor-GC-与-Full-GC-分别在什么时候发生？"><a href="#8-Minor-GC-与-Full-GC-分别在什么时候发生？" class="headerlink" title="8.  Minor GC 与 Full GC 分别在什么时候发生？"></a>8.  Minor GC 与 Full GC 分别在什么时候发生？</h2><p>新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC</p><h2 id="9-几种常用的内存调试工具：jmap、jstack、jconsole、jhat-jstack"><a href="#9-几种常用的内存调试工具：jmap、jstack、jconsole、jhat-jstack" class="headerlink" title="9.  几种常用的内存调试工具：jmap、jstack、jconsole、jhat jstack"></a>9.  几种常用的内存调试工具：jmap、jstack、jconsole、jhat jstack</h2><p>可以看当前栈的情况，jmap 查看内存，jhat 进行 dump 堆的信息mat（eclipse 的也要了解一下）</p><h2 id="10-类加载的几个过程："><a href="#10-类加载的几个过程：" class="headerlink" title="10. 类加载的几个过程："></a>10. 类加载的几个过程：</h2><p>加载、验证、准备、解析、初始化。然后是使用和卸载了</p><p>通过全限定名来加载生成 class 对象到内存中，然后进行验证这个 class 文件，包括文件格式校验、元数据验证，字节码校验等。准备是对这个对象分配内存。解析是将符号引用转化为直接引用（指针引用），初始化就是开始执行构造器的代码</p><h2 id="11-JVM-内存分哪几个区，每个区的作用是什么"><a href="#11-JVM-内存分哪几个区，每个区的作用是什么" class="headerlink" title="11.JVM 内存分哪几个区，每个区的作用是什么?"></a><strong>11.JVM</strong> <strong>内存分哪几个区，每个区的作用是什么?</strong></h2><p>java 虚拟机主要分为以下一个区:<strong>方法区：</strong></p><ol><li><p>有时候也成为<strong>永久代</strong>，在该区内很少发生垃圾回收，但是并不代表不发生 GC，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载</p></li><li><p>方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后</p></li></ol><p>的代码等数据。</p><ol start="3"><li><p>该区域是被线程共享的。</p></li><li><p>方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</p></li></ol><p><strong>虚拟机栈:</strong></p><ol><li>虚拟机栈也就是我们平常所称的<strong>栈内存</strong>,它为 java 方法服务，每个方法在执行的时候都</li></ol><p>会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p><ol start="2"><li><p>虚拟机栈是线程私有的，它的生命周期与线程相同。</p></li><li><p>局部变量表里存储的是基本数据类型、returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</p></li><li><p>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p></li><li><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p></li></ol><p><strong>本地方法栈</strong></p><p>本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。</p><p><strong>堆</strong></p><p>java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p><p><strong>程序计数器</strong></p><p>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。</p><h2 id="12-如和判断一个对象是否存活-或者-GC-对象的判定方法"><a href="#12-如和判断一个对象是否存活-或者-GC-对象的判定方法" class="headerlink" title="12.如和判断一个对象是否存活?(或者 GC 对象的判定方法)"></a><strong>12.如和判断一个对象是否存活?(或者</strong> <strong>GC</strong> <strong>对象的判定方法)</strong></h2><p>判断一个对象是否存活有两种方法: </p><p>\1. <strong>引用计数法</strong></p><p>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. </p><p>引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象B 又引用者对象 A，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p><p>2.<strong>可达性算法</strong>(引用链法)</p><p> 该算法的思想是：从一个被称为 <strong>GC</strong> <strong>Roots</strong> 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。</p><p>在 java 中可以作为 GC Roots 的对象有以下几种: </p><p>·   虚拟机栈中引用的对象 </p><p>·   方法区类静态属性引用的对象 </p><p>·   方法区常量池引用的对象 </p><p>·   本地方法栈 JNI 引用的对象</p><p>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比<strong>不一定会被回收</strong>。当一个对象不可达 GC Root 时，这个对象并</p><p><strong>不会立马被回收</strong>，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记</p><p>如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。</p><p>如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 F- Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行</p><p>第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。</p><h2 id="13-简述-java-垃圾回收机制"><a href="#13-简述-java-垃圾回收机制" class="headerlink" title="13.简述 java 垃圾回收机制?"></a><strong>13.简述</strong> <strong>java</strong> <strong>垃圾回收机制?</strong></h2><p>在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h2 id="14-java-中垃圾收集的方法有哪些"><a href="#14-java-中垃圾收集的方法有哪些" class="headerlink" title="14.java 中垃圾收集的方法有哪些?"></a><strong>14.java</strong> <strong>中垃圾收集的方法有哪些?</strong></h2><ol><li><strong>标记-清除:</strong></li></ol><p>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作 </p><ol start="2"><li>复制算法:**</li></ol><p>为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，</p><p>内存的代价太高，每次基本上都要浪费一般的内存。</p><p>于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(java 堆又分为新生代和老年代)</p><ol start="3"><li><strong>标记-整理</strong></li></ol><p>该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了 </p><ol start="4"><li><strong>分代收集</strong></li></ol><p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用<strong>复制</strong>算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用<strong>标记-整理</strong> 或者 <strong>标记-清除</strong>。</p><h2 id="15-java-内存模型"><a href="#15-java-内存模型" class="headerlink" title="15.java 内存模型"></a><strong>15.java</strong> <strong>内存模型</strong></h2><p>java 内存模型(JMM)是线程间通信的控制机制.JMM 定义了主内存和线程之间抽象关系。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ol><li><p>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</p></li><li><p>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</p></li></ol><h2 id="16-java-类加载过程"><a href="#16-java-类加载过程" class="headerlink" title="16.java 类加载过程?"></a><strong>16.java</strong> <strong>类加载过程?</strong></h2><p>java 类加载需要经历一下 7 个过程：</p><p><strong>加载</strong></p><p>加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p><ol><li><p>通过一个类的全限定名获取该类的二进制流。</p></li><li><p>将该二进制流中的静态存储结构转化为方法去运行时数据结构。</p></li><li><p>在内存中生成该类的 Class 对象，作为该类的数据访问入口。</p></li></ol><p><strong>验证</strong></p><p>验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成</p><p>以下四钟验证:</p><ol><li><p>文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</p></li><li><p>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</p></li><li><p>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</p></li><li><p>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</p></li></ol><p><strong>准备</strong></p><p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p><p>public static int value&#x3D;123;*&#x2F;&#x2F;<strong>在准备阶段</strong>value<strong>初始值为</strong>0<strong>。在初始化阶段才会变</strong>为123*<em>。</em></p><p><strong>解析</strong></p><p>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p><p><strong>初始化</strong></p><p>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</p><h2 id="17-简述-java-类加载机制"><a href="#17-简述-java-类加载机制" class="headerlink" title="17. 简述 java 类加载机制?"></a><strong>17.</strong> <strong>简述</strong> <strong>java</strong> <strong>类加载机制?</strong></h2><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型。</p><h2 id="18-类加载器双亲委派模型机制？"><a href="#18-类加载器双亲委派模型机制？" class="headerlink" title="18. 类加载器双亲委派模型机制？"></a><strong>18.</strong> <strong>类加载器双亲委派模型机制？</strong></h2><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类 </p><p>去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p><h2 id="19-什么是类加载器，类加载器有哪些"><a href="#19-什么是类加载器，类加载器有哪些" class="headerlink" title="19.什么是类加载器，类加载器有哪些?"></a><strong>19.什么是类加载器，类加载器有哪些?</strong></h2><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有一下四种类加载器:</p><ol><li><p>启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。</p></li><li><p>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</p></li><li><p>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。</p></li><li><p>用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</p></li></ol><h2 id="20-简述-java-内存分配与回收策率以及-Minor-GC-和Major-GC"><a href="#20-简述-java-内存分配与回收策率以及-Minor-GC-和Major-GC" class="headerlink" title="20.简述 java 内存分配与回收策率以及 Minor GC 和Major GC"></a><strong>20.简述</strong> <strong>java</strong> <strong>内存分配与回收策率以及</strong> <strong>Minor</strong> <strong>GC</strong> <strong>和Major</strong> <strong>GC</strong></h2><ol><li><p>对象优先在堆的 Eden 区分配。</p></li><li><p>大对象直接进入老年代.</p></li><li><p>长期存活的对象将直接进入老年代.<br>当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快;Full Gc&#x2F;Major GC 发生在老年代，一般情况下，触发老年代 GC的时候不会触发 Minor GC,但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/Dubbo%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/04/27/Dubbo%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-Dubbo-中-zookeeper-做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？"><a href="#1-Dubbo-中-zookeeper-做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？" class="headerlink" title="1.Dubbo 中 zookeeper 做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？"></a>1.<strong>Dubbo</strong> <strong>中</strong> <strong>zookeeper</strong> <strong>做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？</strong></h1><p>可以通信的，启动 dubbo 时，消费者会从 zk 拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用； </p><p>注册中心对等集群，任意一台宕机后，将会切换到另一台；注册中心全部宕机后，服务的提供者和消费者仍能通过本地缓存通讯。服务提供者无状态，任一台 宕机后，不影响使用；服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复； </p><p>挂掉是不要紧的，但前提是你没有增加新的服务，如果你要调用新的服务，则是不能办到的。 </p><p> 附文档截图：</p><h1 id="2-dubbo-服务负载均衡策略？"><a href="#2-dubbo-服务负载均衡策略？" class="headerlink" title="2.dubbo 服务负载均衡策略？"></a><strong>2.dubbo</strong> <strong>服务负载均衡策略？</strong></h1><p>l Random LoadBalance </p><p>  随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比</p><p>较均匀，有利于动态调整提供者权重。(权重可以在 dubbo 管控台配置) </p><table><thead><tr><th>1</th><th>&lt;dubbo:parameter key&#x3D;”hash.arguments” value&#x3D;”0,1” &#x2F;&gt;</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>1</th><th>&lt;dubbo:parameter key&#x3D;”hash.nodes” value&#x3D;”320” &#x2F;&gt;</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>l RoundRobin LoadBalance </p><p>  轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调</p><p>到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 </p><p>l LeastActive LoadBalance </p><p>  最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的</p><p>调用前后计数差会越大。 </p><p>l ConsistentHash LoadBalance </p><p>一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。缺省只对第一个参数 Hash，如果要修改，请配置 </p><p><code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></p><p>缺省用 160 份虚拟节点，如果要修改，请配置 </p><p><code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></p><h1 id="3-Dubbo-在安全机制方面是如何解决的"><a href="#3-Dubbo-在安全机制方面是如何解决的" class="headerlink" title="3. Dubbo 在安全机制方面是如何解决的"></a>3. <strong>Dubbo</strong> <strong>在安全机制方面是如何解决的</strong></h1><p>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo 还提供服务黑白名单，来控</p><p>制服务所允许的调用方。 </p><h1 id="4-dubbo-连接注册中心和直连的区别"><a href="#4-dubbo-连接注册中心和直连的区别" class="headerlink" title="4. dubbo 连接注册中心和直连的区别"></a>4. <strong>dubbo</strong> <strong>连接注册中心和直连的区别</strong></h1><p>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连， </p><p>点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表， </p><p>服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 </p><p>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 </p><p>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。 </p><ol><li><strong>dubbo</strong> <strong>服务集群配置（集群容错模式）</strong></li></ol><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。可以自行扩展集群容错策略 </p><p>l Failover Cluster(默认) </p><p>  失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，但重试会带来更长延迟。可通过retries&#x3D;”2”来设置重试次数(不含第一次)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service retries=&quot;2&quot; cluster=&quot;failover&quot;/&gt;      或：         &lt;dubbo:reference retries=&quot;2&quot; cluster=&quot;failover&quot;/&gt;         cluster=&quot;failover&quot;可以不用写,因为默认就是 failover   </span><br></pre></td></tr></table></figure><p>l Failfast Cluster </p><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo:service cluster=&quot;failfast&quot; /&gt;      或：        </span><br><span class="line">&lt;dubbo:reference cluster=&quot;failfast&quot; /&gt;   </span><br><span class="line">cluster=&quot;failfast&quot;和 把 cluster=&quot;failover&quot;、retries=&quot;0&quot;是一样的效果,retries=&quot;0&quot;就是不重试   </span><br></pre></td></tr></table></figure><p>l Failsafe Cluster </p><p>  失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;          或： </span><br><span class="line">&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</span><br></pre></td></tr></table></figure><p>l Failback Cluster </p><p>  失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service cluster=&quot;failback&quot; /&gt;          或： </span><br><span class="line">         &lt;dubbo:reference cluster=&quot;failback&quot; /&gt; </span><br></pre></td></tr></table></figure><p>l Forking Cluster </p><p>  并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks&#x3D;”2”来设置最大并行数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service cluster=“forking&quot; forks=&quot;2&quot;/&gt;          或： </span><br><span class="line">         &lt;dubbo:reference cluster=“forking&quot; forks=&quot;2&quot;/&gt; </span><br></pre></td></tr></table></figure><p>l 配置 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">服务端服务级别</span><br><span class="line">&lt;dubbo:service interface=&quot;...&quot;  oadbalance=&quot;roundrobin&quot; /&gt;</span><br><span class="line">客户端服务级别</span><br><span class="line">&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br><span class="line">服务端方法级别</span><br><span class="line">&lt;dubbo:service interface=&quot;...&quot;&gt;   &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;</span><br><span class="line">客户端方法级别</span><br><span class="line">&lt;dubbo:reference interface=&quot;..&quot;&gt;&lt;dubbo:method name=&quot;...&quot;  loadbalance=&quot;roundrobin&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-dubbo-通信协议-dubbo-协议为什么要消费者比提供者个数多："><a href="#1-dubbo-通信协议-dubbo-协议为什么要消费者比提供者个数多：" class="headerlink" title="1. dubbo 通信协议 dubbo 协议为什么要消费者比提供者个数多："></a>1. <strong>dubbo</strong> <strong>通信协议</strong> <strong>dubbo</strong> <strong>协议为什么要消费者比提供者个数多：</strong></h2><p>因 dubbo 协议采用单一长连接，假设网络为千兆网卡(1024Mbit&#x3D;128MByte)， </p><p>根据测试经验数据每条连接最多只能压满 7MByte(不同的环境可能不一样，供参考)，理论上 1 个服务提供者需要 20</p><p>个服务消费者才能压满网卡。 </p><h2 id="2-dubbo-通信协议-dubbo-协议为什么不能传大包："><a href="#2-dubbo-通信协议-dubbo-协议为什么不能传大包：" class="headerlink" title="2. dubbo 通信协议 dubbo 协议为什么不能传大包："></a>2. <strong>dubbo</strong> <strong>通信协议</strong> <strong>dubbo</strong> <strong>协议为什么不能传大包：</strong></h2><p>因 dubbo 协议采用单一长连接， </p><p>如果每次请求的数据包大小为 500KByte，假设网络为千兆网卡(1024Mbit&#x3D;128MByte)，每条连接最大 7MByte(不同的环境可能不一样，供参考)， </p><p>单个服务提供者的 TPS(每秒处理事务数)最大为：128MByte &#x2F; 500KByte &#x3D; 262。 </p><p>单个消费者调用单个服务提供者的 TPS(每秒处理事务数)最大为：7MByte &#x2F; 500KByte &#x3D; 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。 </p><h2 id="3-dubbo-通信协议-dubbo-协议为什么采用异步单一长连接："><a href="#3-dubbo-通信协议-dubbo-协议为什么采用异步单一长连接：" class="headerlink" title="3. dubbo 通信协议 dubbo 协议为什么采用异步单一长连接："></a>3. <strong>dubbo</strong> <strong>通信协议</strong> <strong>dubbo</strong> <strong>协议为什么采用异步单一长连接：</strong></h2><p>因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务， </p><p>比如 Morgan 的提供者只有 6 台提供者，却有上百台消费者，每天有 1.5 亿次调用，如果采用常规的 hessian 服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等， </p><p>并使用异步 IO，复用线程池，防止 C10K 问题。 </p><h2 id="4-dubbo-通信协议-dubbo-协议适用范围和适用场景"><a href="#4-dubbo-通信协议-dubbo-协议适用范围和适用场景" class="headerlink" title="4. dubbo 通信协议 dubbo 协议适用范围和适用场景"></a>4. <strong>dubbo</strong> <strong>通信协议</strong> <strong>dubbo</strong> <strong>协议适用范围和适用场景</strong></h2><p>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。 </p><p>适用场景：常规远程服务方法调用 dubbo协议补充： </p><p>连接个数：单连接连接方式：长连接传输协议：TCP </p><p>传输方式：NIO 异步传输 </p><p>序列化：Hessian 二进制序列化 </p><h2 id="5-RMI-协议"><a href="#5-RMI-协议" class="headerlink" title="5. RMI 协议"></a>5. <strong>RMI</strong> <strong>协议</strong></h2><p>RMI协议采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式，Java标准的远程调用协议。 </p><p>连接个数：多连接连接方式：短连接传输协议：TCP 传输方式：同步传输序列化：Java标准二进制序列化 </p><p>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。 </p><p>适用场景：常规远程服务方法调用，与原生RMI服务互操作 </p><h2 id="6-Hessian-协议"><a href="#6-Hessian-协议" class="headerlink" title="6. Hessian 协议"></a>6. <strong>Hessian</strong> <strong>协议</strong></h2><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用</p><p>Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现基于Hessian的远程调用协议。 </p><p>连接个数：多连接连接方式：短连接传输协议：HTTP 传输方式：同步传输 </p><p>序列化：Hessian二进制序列化适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。 </p><p>适用场景：页面传输，文件传输，或与原生hessian服务互操作 </p><h2 id="7-http"><a href="#7-http" class="headerlink" title="7. http"></a>7. <strong>http</strong></h2><p>采用Spring的HttpInvoker实现基于http表单的远程调用协议。 </p><p>连接个数：多连接连接方式：短连接传输协议：HTTP 传输方式：同步传输序列化：表单序列化（JSON） </p><p>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。适用场景：需同时给应用程序和浏览器JS使用的服务。 </p><h2 id="8-Webservice"><a href="#8-Webservice" class="headerlink" title="8. Webservice"></a>8. <strong>Webservice</strong></h2><p>基于CXF的frontend-simple和transports-http实现基于WebService的远程调用协议。 </p><p>连接个数：多连接连接方式：短连接传输协议：HTTP 传输方式：同步传输 </p><p>序列化：SOAP文本序列化适用场景：系统集成，跨语言调用。 </p><h2 id="9-Thrif"><a href="#9-Thrif" class="headerlink" title="9. Thrif"></a>9. <strong>Thrif</strong></h2><p>Thrift是Facebook捐给Apache的一个RPC框架，当前 dubbo 支持的 thrift 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如service name，magic number等 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/Dubbo%E9%9D%A2%E8%AF%95%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/04/27/Dubbo%E9%9D%A2%E8%AF%95%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Dubbo-支持哪些协议，每种协议的应用场景，优缺点？"><a href="#Dubbo-支持哪些协议，每种协议的应用场景，优缺点？" class="headerlink" title="Dubbo 支持哪些协议，每种协议的应用场景，优缺点？"></a><strong>Dubbo</strong> <strong>支持哪些协议，每种协议的应用场景，优缺点？</strong></h1><p>•    <strong>dubbo：</strong> 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化； </p><p>•    <strong>rmi：</strong> 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现</p><p>Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 </p><p>多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全漏洞； </p><p>•    <strong>webservice：</strong> 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用； </p><p>•    <strong>http：</strong> 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用； </p><p>•    <strong>hessian：</strong> 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务， Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件； </p><p>•    <strong>memcache：</strong> 基于 memcached 实现的 RPC 协议 </p><p>•    <strong>redis：</strong> 基于 redis 实现的 RPC 协议 </p><h1 id="Dubbo-超时时间怎样设置？"><a href="#Dubbo-超时时间怎样设置？" class="headerlink" title="Dubbo 超时时间怎样设置？"></a><strong>Dubbo</strong> <strong>超时时间怎样设置？</strong></h1><p>　Dubbo 超时时间设置有两种方式： </p><p>•    服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。 </p><p>•    服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。 </p><h1 id="Dubbo-有些哪些注册中心？"><a href="#Dubbo-有些哪些注册中心？" class="headerlink" title="Dubbo 有些哪些注册中心？"></a><strong>Dubbo</strong> <strong>有些哪些注册中心？</strong></h1><p>•    <strong>Multicast</strong> <strong>注册中心：</strong> Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现； </p><p>•    <strong>Zookeeper</strong> <strong>注册中心：</strong> 基于分布式协调系统 Zookeeper 实现，采用</p><p>Zookeeper 的 watch 机制实现数据变更； </p><p>•    <strong>redis</strong> <strong>注册中心：</strong> 基于 redis 实现，采用 key&#x2F;Map 存储，住 key 存储服务名和类型，Map 中 key 存储服务 URL，value 服务过期时间。基于 redis 的发布&#x2F;订阅模式通知数据变更； </p><p>•    <strong>Simple</strong> <strong>注册中心</strong> </p><h1 id="Dubbo-集群的负载均衡有哪些策略"><a href="#Dubbo-集群的负载均衡有哪些策略" class="headerlink" title="Dubbo 集群的负载均衡有哪些策略"></a><strong>Dubbo</strong> <strong>集群的负载均衡有哪些策略</strong></h1><p>　Dubbo 提供了常见的集群策略实现，并预扩展点予以自行实现。 </p><p>•    <strong>Random LoadBalance:</strong> 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀； </p><p>•    <strong>RoundRobin LoadBalance:</strong> 轮循选取提供者策略，平均分布，但是存在请求累积的问题； </p><p>•    <strong>LeastActive LoadBalance:</strong> 最少活跃调用策略，解决慢提供者接收更少的请求； </p><p>•    <strong>ConstantHash LoadBalance:</strong> 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动； </p><h1 id="-Dubbo-是什么？"><a href="#-Dubbo-是什么？" class="headerlink" title=" Dubbo 是什么？"></a> Dubbo 是什么？</h1><p> Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提</p><p>供服务自动注册、自动发现等高效服务治理方案， 可以和 </p><p>Spring 框架无缝集成。 </p><h1 id="-Dubbo-的主要应用场景？"><a href="#-Dubbo-的主要应用场景？" class="headerlink" title=" Dubbo 的主要应用场景？"></a> Dubbo 的主要应用场景？</h1><p>•    透明化的远程方法调用，就像调用本地方法一样调用远程方法，</p><p>只需简单配置，没有任何 API 侵入。 </p><p>•    软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，</p><p>降低成本，减少单点。 </p><p>•    服务自动注册与发现，不再需要写死服务提供方地址，注册中心</p><p>基于接口名查询服务提供者的 IP 地址，并且能够平滑添加或删</p><p>除服务提供者。 </p><h1 id="Dubbo-的核心功能？"><a href="#Dubbo-的核心功能？" class="headerlink" title="Dubbo 的核心功能？"></a>Dubbo 的核心功能？</h1><p>主要就是如下 3 个核心功能： </p><p>§ <strong>Remoting：</strong>网络通信框架，提供对多种 NIO 框架抽象封装，包括</p><p>“同步转异步”和“请求-响应”模式的信息交换方式。 </p><p>§ <strong>Cluster：服务框架</strong>，提供基于接口方法的透明远程过程调用，包括多</p><p>协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群</p><p>支持。 </p><p><strong>Registry：服务注册</strong>，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p><p><img src="/Dubbo%E9%9D%A2%E8%AF%95%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.assets/1.png" alt="1"></p><h1 id="Dubbo-的核心组件？"><a href="#Dubbo-的核心组件？" class="headerlink" title="Dubbo 的核心组件？"></a><strong>Dubbo</strong> <strong>的核心组件？</strong></h1><h1 id="Dubbo-服务注册与发现的流程？"><a href="#Dubbo-服务注册与发现的流程？" class="headerlink" title="Dubbo 服务注册与发现的流程？"></a>Dubbo 服务注册与发现的流程？</h1><p><img src="/Dubbo%E9%9D%A2%E8%AF%95%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.assets/2.jpg" alt="2"></p><h1 id="流程说明："><a href="#流程说明：" class="headerlink" title="流程说明："></a>流程说明：</h1><p>§ Provider(提供者)绑定指定端口并启动服务 </p><p>§ 指供者连接注册中心，并发本机 IP、端口、应用信息和提供服务信息</p><p>发送至注册中心存储 </p><p>§ Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信</p><p>息至注册中心 </p><p>§ 注册中心根据 消费 者所求服务信息匹配对应的提供者列表发送至</p><p>Consumer 应用缓存。 </p><p>§ Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调</p><p>用。 </p><p>Provider 状态变更会实时通知注册中心、在由注册中心实时推送至</p><p>Consumer </p><h1 id="设计的原因："><a href="#设计的原因：" class="headerlink" title="设计的原因："></a>设计的原因：</h1><ul><li>Consumer 与 Provider 解偶，双方都可以横向增减节点数。 </li><li>注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台 </li><li>去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用 </li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li></ul><p><img src="/Dubbo%E9%9D%A2%E8%AF%95%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.assets/3.jpg" alt="3"></p><h1 id="Dubbo-的架构设计？"><a href="#Dubbo-的架构设计？" class="headerlink" title="Dubbo 的架构设计？"></a>Dubbo 的架构设计？</h1><p><img src="/Dubbo%E9%9D%A2%E8%AF%95%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.assets/4.jpg" alt="4"></p><h1 id="Dubbo-框架设计一共划分了-10-个层："><a href="#Dubbo-框架设计一共划分了-10-个层：" class="headerlink" title="Dubbo 框架设计一共划分了 10 个层："></a>Dubbo 框架设计一共划分了 10 个层：</h1><ul><li><p><strong>服务接口层（Service）</strong>：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。 </p></li><li><p><strong>配置层（Config）</strong>：对外配置接口，以 ServiceConfig 和ReferenceConfig 为中心。 </p></li><li><p><strong>服务代理层（Proxy</strong>）：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton。 </p></li><li><p><strong>服务注册层（Registry）</strong>：封装服务地址的注册与发现，以服务 URL为中心。 </p></li><li><p><strong>集群层（Cluster）</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心。 </p></li><li><p><strong>监控层（Monitor）</strong>：RPC 调用次数和调用时间监控。 </p></li><li><p><strong>远程调用层（Protocol）</strong>：封将 RPC 调用，以 Invocation 和 Result为中心，扩展接口为 Protocol、Invoker 和 Exporter。 </p></li><li><p><strong>信息交换层（Exchange）</strong>：封装请求响应模式，同步转异步，以Request 和 Response 为中心。 </p></li><li><p><strong>网络传输层（Transport）</strong>：抽象 mina 和 netty 为统一接口，以essage 为中心。</p></li></ul><h1 id="Dubbo-的服务调用流程？"><a href="#Dubbo-的服务调用流程？" class="headerlink" title="Dubbo 的服务调用流程？"></a>Dubbo 的服务调用流程？</h1><p><img src="/Dubbo%E9%9D%A2%E8%AF%95%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.assets/5.jpg" alt="5"></p><h1 id="Dubbo-支持哪些协议，每种协议的应用场景，优缺点？-1"><a href="#Dubbo-支持哪些协议，每种协议的应用场景，优缺点？-1" class="headerlink" title="Dubbo 支持哪些协议，每种协议的应用场景，优缺点？"></a>Dubbo 支持哪些协议，每种协议的应用场景，优缺点？</h1><ul><li><strong>dubbo：</strong> 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化； <strong>rmi：</strong> 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections包，java 序列化存在安全漏洞； </li><li><strong>webservice：</strong> 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用； </li><li><strong>http：</strong> 基于 Http 表单提交的远程调用协议，使用 Spring 的HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用； </li><li><strong>hessian：</strong> 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件； </li><li><strong>memcache：</strong> 基于 memcached 实现的 RPC 协议 </li><li><strong>redis：</strong> 基于 redis 实现的 RPC 协议 <strong>dubbo</strong> <strong>推荐用什么协议？</strong><br>  默认使用 dubbo 协议</li></ul><h1 id="Dubbo-有些哪些注册中心？-1"><a href="#Dubbo-有些哪些注册中心？-1" class="headerlink" title="Dubbo 有些哪些注册中心？"></a>Dubbo 有些哪些注册中心？</h1><ul><li><strong>Multicast</strong> <strong>注册中心：</strong> Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现； </li><li><strong>Zookeeper</strong> <strong>注册中心：</strong> 基于分布式协调系统 Zookeeper 实现，采用Zookeeper 的 watch 机制实现数据变更； </li><li><strong>redis</strong> <strong>注册中心：</strong> 基于 redis 实现，采用 key&#x2F;Map 存储，住 key 存储服务名和类型，Map 中 key 存储服务 URL，value 服务过期时间。基于 redis 的发布&#x2F;订阅模式通知数据变更； </li><li><strong>Simple</strong> <strong>注册中心</strong></li></ul><p><strong>Dubbo</strong> <strong>默认采用注册中心？</strong> </p><p>采用 Zookeeper </p><h1 id="为什么需要服务治理？"><a href="#为什么需要服务治理？" class="headerlink" title="为什么需要服务治理？"></a>为什么需要服务治理？</h1><p><img src="/Dubbo%E9%9D%A2%E8%AF%95%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.assets/6.jpg" alt="6"></p><ul><li>过多的服务 URL 配置困难 </li><li>负载均衡分配节点压力过大的情况下也需要部署集群服务依赖混乱，启动顺序不清晰 </li><li>过多服务导致性能指标分析难度较大，需要监控</li></ul><h1 id="Dubbo-的注册中心集群挂掉，发布者和订阅者之间还能通信么？"><a href="#Dubbo-的注册中心集群挂掉，发布者和订阅者之间还能通信么？" class="headerlink" title="Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？"></a>Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？</h1><p>可以的，启动 dubbo 时，消费者会从 zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。 </p><p>每次调用时，按照本地存储的地址进行调用。 </p><h1 id="Dubbo-与-Spring-的关系？"><a href="#Dubbo-与-Spring-的关系？" class="headerlink" title="Dubbo 与 Spring 的关系？"></a>Dubbo 与 Spring 的关系？</h1><p>Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何</p><p>API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于</p><p>Spring 的 Schema 扩展进行加载。 </p><p><strong>Dubbo</strong> <strong>使用的是什么通信框架?</strong> </p><p>默认使用 NIO Netty 框架 </p><h1 id="Dubbo-集群提供了哪些负载均衡策略？"><a href="#Dubbo-集群提供了哪些负载均衡策略？" class="headerlink" title="Dubbo 集群提供了哪些负载均衡策略？"></a>Dubbo 集群提供了哪些负载均衡策略？</h1><ul><li><strong>Random LoadBalance:</strong> 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀； </li><li><strong>RoundRobin LoadBalance:</strong> 轮循选取提供者策略，平均分布，但是存在请求累积的问题；</li></ul><h1 id="LeastActive-LoadBalance-最少活跃调用策略，解决慢提供者接收"><a href="#LeastActive-LoadBalance-最少活跃调用策略，解决慢提供者接收" class="headerlink" title="LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收"></a>LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收</h1><p>更少的请求； </p><p><strong>ConstantHash LoadBalance:</strong> 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动； </p><p>缺省时为 Random 随机调用 </p><p><strong>Dubbo</strong> <strong>的集群容错方案有哪些？</strong> </p><h1 id="Failover-Cluster"><a href="#Failover-Cluster" class="headerlink" title="Failover Cluster"></a>Failover Cluster</h1><p> 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但</p><p>重试会带来更长延迟。 </p><h1 id="Failfast-Cluster"><a href="#Failfast-Cluster" class="headerlink" title="Failfast Cluster"></a>Failfast Cluster</h1><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 </p><p><strong>Failsafe Cluster</strong></p><p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 </p><h1 id="Failback-Cluster"><a href="#Failback-Cluster" class="headerlink" title="Failback Cluster"></a>Failback Cluster</h1><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 </p><p><strong>Forking Cluster</strong> 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks&#x3D;”2” 来设置最大并行数。 </p><h1 id="roadcast-Cluster"><a href="#roadcast-Cluster" class="headerlink" title="roadcast Cluster"></a>roadcast Cluster</h1><p>广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。 </p><p><strong>Dubbo</strong> <strong>的默认集群容错方案？</strong> </p><p>Failover Cluster </p><h1 id="Dubbo-支持哪些序列化方式？"><a href="#Dubbo-支持哪些序列化方式？" class="headerlink" title="Dubbo 支持哪些序列化方式？"></a>Dubbo 支持哪些序列化方式？</h1><p>默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。 </p><h1 id="Dubbo-超时时间怎样设置？-1"><a href="#Dubbo-超时时间怎样设置？-1" class="headerlink" title="Dubbo 超时时间怎样设置？"></a>Dubbo 超时时间怎样设置？</h1><p>Dubbo 超时时间设置有两种方式： </p><ul><li>服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。 </li><li>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</li></ul><p><strong>服务调用超时问题怎么解决？</strong> </p><p>dubbo 在调用服务不成功时，默认是会重试两次的。 </p><h1 id="Dubbo-在安全机制方面是如何解决？"><a href="#Dubbo-在安全机制方面是如何解决？" class="headerlink" title="Dubbo 在安全机制方面是如何解决？"></a>Dubbo 在安全机制方面是如何解决？</h1><p>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。 </p><h1 id="Dubbo-和-Dubbox-之间的区别？"><a href="#Dubbo-和-Dubbox-之间的区别？" class="headerlink" title="Dubbo 和 Dubbox 之间的区别？"></a>Dubbo 和 Dubbox 之间的区别？</h1><p>dubbox 基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。 </p><h1 id="Dubbo-和-Spring-Cloud-的关系？"><a href="#Dubbo-和-Spring-Cloud-的关系？" class="headerlink" title="Dubbo 和 Spring Cloud 的关系？"></a>Dubbo 和 Spring Cloud 的关系？</h1><p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、</p><p>Spirng Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、Spirng Cloud 是一个生态。 </p><h1 id="Dubbo-和-Spring-Cloud-的区别？"><a href="#Dubbo-和-Spring-Cloud-的区别？" class="headerlink" title="Dubbo 和 Spring Cloud 的区别？"></a>Dubbo 和 Spring Cloud 的区别？</h1><p><img src="/Dubbo%E9%9D%A2%E8%AF%95%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.assets/7.jpg" alt="7"></p><p>最大的区别：Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。 </p><p>而 SpringCloud 是基于 Http 协议+Rest 接口调用远程过程的通信，相对来说，Http 请求会有更大的报文，占的带宽也会更多。但是REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/46%E4%B8%AA%E7%BB%8F%E5%85%B8Linux%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%81/"/>
      <url>/2022/04/27/46%E4%B8%AA%E7%BB%8F%E5%85%B8Linux%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题一：绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示-切换目录用什么命令？"><a href="#问题一：绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示-切换目录用什么命令？" class="headerlink" title="问题一：绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示 ? 切换目录用什么命令？"></a><strong>问题一：</strong>绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示 ? 切换目录用什么命令？</h2><h2 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h2><p>绝对路径：如&#x2F;etc&#x2F;init.d</p><p>当前目录和上层目录：.&#x2F; ..&#x2F; 主目录：~&#x2F;</p><p>切换目录：cd</p><h2 id="问题二：怎么查看当前进程？怎么执行退出？怎么查看当前路径？答案："><a href="#问题二：怎么查看当前进程？怎么执行退出？怎么查看当前路径？答案：" class="headerlink" title="问题二：怎么查看当前进程？怎么执行退出？怎么查看当前路径？答案："></a><strong>问题二：</strong>怎么查看当前进程？怎么执行退出？怎么查看当前路径？<strong>答案：</strong></h2><p>查看当前进程：ps 执行退出：exit</p><p>查看当前路径：pwd</p><h2 id="问题三：怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户-id？查看指定帮助用什么命令？"><a href="#问题三：怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户-id？查看指定帮助用什么命令？" class="headerlink" title="问题三：怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？"></a><strong>问题三：</strong>怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？</h2><h2 id="答案：-1"><a href="#答案：-1" class="headerlink" title="答案："></a><strong>答案：</strong></h2><p>清屏：clear</p><p>退出当前命令：ctrl+c 彻底退出执行睡眠 ：ctrl+z 挂起当前进程 fg 恢复后台查看当前用户 id：”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名</p><p>查看指定帮助：如 man adduser 这个很全 而且有例子；adduser –help 这个告诉你一些常用参数；info adduesr；</p><h2 id="问题四："><a href="#问题四：" class="headerlink" title="问题四："></a>问题四：</h2><p>Ls 命令执行什么功能？可以带哪些参数，有什么区别？<strong>答案：</strong> ls 执行的功能：列出指定目录中的目录，以及文件哪些参数以及区别：a 所有文件 l 详细信息，包括大小字节数，可读可写可执行的权限等</p><h2 id="问题五：建立软链接-快捷方式-，以及硬链接的命令。"><a href="#问题五：建立软链接-快捷方式-，以及硬链接的命令。" class="headerlink" title="问题五：建立软链接(快捷方式)，以及硬链接的命令。"></a><strong>问题五：</strong>建立软链接(快捷方式)，以及硬链接的命令。</h2><h2 id="答案：-2"><a href="#答案：-2" class="headerlink" title="答案："></a>答案：</h2><p>软链接：ln -s slink source 硬链接：ln link source</p><h2 id="问题六：目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？答案："><a href="#问题六：目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？答案：" class="headerlink" title="问题六：目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？答案："></a><strong>问题六：</strong>目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？<strong>答案：</strong></h2><p>创建目录：mkdir</p><p>创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件复制文件：cp 7. 文件权限修改用什么命令？格式是怎么样的？文件权限修改：chmod</p><p>格式如下：</p><p>$ chmod u+x file 给 file 的属主增加执行权限</p><p>$ chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p><p>$ chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x file 上例的另一种形式</p><p>$ chmod &#x3D;r file 为所有用户分配读权限</p><p>$ chmod 444 file 同上例</p><p>$ chmod a-wx,a+r file 同上例</p><p>$ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限</p><h2 id="问题八：查看文件内容有哪些命令可以使用？答案："><a href="#问题八：查看文件内容有哪些命令可以使用？答案：" class="headerlink" title="问题八：查看文件内容有哪些命令可以使用？答案："></a><strong>问题八：</strong>查看文件内容有哪些命令可以使用？<strong>答案：</strong></h2><p>vi 文件名 #编辑方式查看，可修改 cat 文件名 #显示全部文件内容 more 文件名 #分页显示文件内容 less 文件名 #与 more 相似，更好的是可以往前翻页 tail 文件名 #仅查看尾部，还可以指定行数 head 文件名 #仅查看头部,还可以指定行数</p><h2 id="问题九："><a href="#问题九：" class="headerlink" title="问题九："></a><strong>问题九：</strong></h2><h2 id="随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello-world”"><a href="#随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello-world”" class="headerlink" title="随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?"></a>随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?</h2><h2 id="答案：-3"><a href="#答案：-3" class="headerlink" title="答案："></a>答案：</h2><p>写文件命令：vi</p><p>向屏幕输出带空格的字符串:echo hello world</p><h2 id="问题十：终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？答案："><a href="#问题十：终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？答案：" class="headerlink" title="问题十：终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？答案："></a><strong>问题十：</strong>终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？<strong>答案：</strong></h2><p>终端 &#x2F;dev&#x2F;tty</p><p>黑洞文件 &#x2F;dev&#x2F;null</p><h2 id="问题十一：移动文件用哪个命令？改名用哪个命令？答案：-mv-mv"><a href="#问题十一：移动文件用哪个命令？改名用哪个命令？答案：-mv-mv" class="headerlink" title="问题十一：移动文件用哪个命令？改名用哪个命令？答案： mv mv"></a><strong>问题十一：</strong>移动文件用哪个命令？改名用哪个命令？<strong>答案：</strong> mv mv</h2><h2 id="问题十二："><a href="#问题十二：" class="headerlink" title="问题十二："></a>问题十二：</h2><p>[root@localhost ~]# whatis zcat zcat [gzip] (1) – compress or expand files</p><h2 id="问题四十六：使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？"><a href="#问题四十六：使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？" class="headerlink" title="问题四十六：使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？"></a><strong>问题四十六：</strong>使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？</h2><p><strong>答案：</strong>使用命令 repquota 能够显示出一个文件系统的配额信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/1%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/1%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>BeanFactory</strong> <strong>和 ApplicationContext 有什么区别</strong> </p><p>&gt; BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。 </p><p>&gt; BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。 </p><p>&gt; 从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。 </p><p>&gt; 提供了支持国际化的文本消息 </p><p>&gt; 统一的资源文件读取方式 </p><p>&gt; 已在监听器中注册的bean的事件 </p><p><strong>Spring Bean</strong> <strong>的生命周期</strong> </p><p>&gt; Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。 </p><p>&gt; Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。 </p><p>&gt; 初始化之后调用的回调方法。 </p><p>&gt; 销毁之前调用的回调方法。 </p><p>&gt; Spring框架提供了以下四种方式来管理bean的生命周期事件： </p><p>&gt; InitializingBean和DisposableBean回调接口 </p><p>&gt; 针对特殊行为的其他Aware接口 </p><p>&gt; Bean配置文件中的Custom init()方法和destroy()方法 </p><p>&gt; @PostConstruct和@PreDestroy注解方式 </p><p><strong>Spring IOC</strong> <strong>如何实现</strong> </p><p>&gt; Spring中的 org.springframework.beans 包和 org.springframework.context包构成了</p><p>Spring框架IoC容器的基础。 </p><p>&gt; BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。</p><p>ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的</p><p>WebApplicationContext。 </p><p>&gt; org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。 </p><p> <strong>说说 Spring AOP</strong> </p><p>&gt; 面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志， </p><p>&gt; 通过spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。 </p><p><strong>Spring AOP</strong> <strong>实现原理</strong> </p><p>&gt; Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。 </p><p>&gt; 如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB （Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。 </p><p><strong>动态代理（cglib 与 JDK）</strong> </p><p>&gt; JDK 动态代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用Java动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，就不能使用该机制。而CGLIB则可以实现对类的动态代理。 </p><p><strong>Spring</strong> <strong>事务实现方式</strong> </p><p>&gt; 1、编码方式 </p><p>&gt; 所谓编程式事务指的是通过编码方式实现事务，即类似于JDBC编程实现事务管理。 </p><p>&gt; 2、声明式事务管理方式 </p><p>&gt; 声明式事务管理又有两种实现方式：基于xml配置文件的方式；另一个实在业务方法上进行@Transaction注解，将事务规则应用到业务逻辑中 </p><p><strong>Spring</strong> <strong>事务底层原理</strong> </p><p>&gt; a、划分处理单元——IOC </p><p>&gt; 由于spring解决的问题是对单个数据库进行局部事务处理的，具体的实现首相用spring 中的IOC划分了事务处理单元。并且将对事务的各种配置放到了ioc容器中（设置事务管理器，设置事务的传播特性及隔离机制）。 </p><p>&gt; b、AOP拦截需要进行事务处理的类 </p><p>&gt; Spring事务处理模块是通过AOP功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用TransactionProxyFactoryBean接口来使用AOP</p><p>功能，生成proxy代理对象，通过TransactionInterceptor完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。读取ioc容器事务配置属性，转化为spring事务处理</p><p>需要的内部数据结构（TransactionAttributeSourceAdvisor），转化为 TransactionAttribute表示的数据对象。 </p><p>&gt; c、对事物处理实现（事务的生成、提交、回滚、挂起） </p><p>&gt; spring委托给具体的事务处理器实现。实现了一个抽象和适配。适配的具体事务处理器：DataSource数据源支持、hibernate数据源事务处理支持、JDO数据源事务处理支持，JPA、JTA数据源事务处理支持。这些支持都是通过设计</p><p>PlatformTransactionManager、AbstractPlatforTransaction一系列事务处理的支持。 为常用数据源支持提供了一系列的TransactionManager。 </p><p>&gt; d、结合 </p><p>&gt; PlatformTransactionManager实现了TransactionInterception接口，让其与</p><p>TransactionProxyFactoryBean结合起来，形成一个Spring声明式事务处理的设计体系。 </p><p><strong>如何自定义注解实现功能</strong> </p><p>&gt; 创建自定义注解和创建一个接口相似，但是注解的interface关键字需要以@符号开头。 </p><p>&gt; 注解方法不能带有参数； </p><p>&gt; 注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组； </p><p>&gt; 注解方法可以有默认值； </p><p>&gt; 注解本身能够包含元注解，元注解被用来注解其它注解。 </p><h1 id="Spring-MVC-运行流程"><a href="#Spring-MVC-运行流程" class="headerlink" title="Spring MVC 运行流程"></a>Spring MVC 运行流程</h1><p>&gt; 1.spring mvc将所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责对请求 进行真正的处理工作。 </p><p>&gt; 2.DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller. </p><p>&gt; 3.DispatcherServlet请请求提交到目标Controller </p><p>&gt; 4.Controller进行业务逻辑处理后，会返回一个ModelAndView </p><p>&gt; 5.Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象 </p><p>&gt; 6.视图对象负责渲染返回给客户端。 </p><h1 id="Spring-MVC-启动流程"><a href="#Spring-MVC-启动流程" class="headerlink" title="Spring MVC 启动流程"></a>Spring MVC 启动流程</h1><p>&gt; 在 web.xml 文件中给 Spring MVC 的 Servlet 配置了 load-on-startup,所以程序启动的 &gt; 时候会初始化 Spring MVC，在 HttpServletBean 中将配置的 contextConfigLocation </p><p>&gt; 属性设置到 Servlet 中，然后在 FrameworkServlet 中创建了 WebApplicationContext, </p><p>&gt; DispatcherServlet 根据 contextConfigLocation 配置的 classpath 下的 xml 文件初始化了 </p><p>&gt; Spring MVC 总的组件。 </p><p> <strong>Spring</strong> <strong>的单例实现原理</strong> </p><p>&gt; Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是</p><p>ConcurrentHashMap 对象。 </p><p><strong>Spring</strong> <strong>框架中用到了哪些设计模式</strong> </p><p>&gt; 代理模式—在AOP和remoting中被用的比较多。 </p><p>&gt; 单例模式—在spring配置文件中定义的bean默认为单例模式。 &gt; 模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, </p><p>JpaTemplate。 </p><p>&gt; 前端控制器—Spring提供了DispatcherServlet来对请求进行分发。 </p><p>&gt; 视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。 </p><p>&gt; 依赖注入—贯穿于BeanFactory &#x2F; ApplicationContext接口的核心理念。 </p><p>&gt; 工厂模式—BeanFactory用来创建对象的实例。 </p><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="为什么选择-Netty"><a href="#为什么选择-Netty" class="headerlink" title="为什么选择 Netty"></a>为什么选择 Netty</h2><p>&gt; 1) API使用简单，开发门槛低； </p><p>&gt; 2) 功能强大，预置了多种编解码功能，支持多种主流协议； </p><p>&gt; 3) 定制能力强，可以通过 ChannelHandler 对通信框架进行灵活的扩展； </p><p>&gt; 4) 性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优； </p><p>&gt; 5) 成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为</p><p>NIO的BUG而烦恼； </p><p>&gt; 6) 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入； </p><p>&gt; 7) 经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。 </p><p>&gt; 正是因为这些优点，Netty逐渐成为Java NIO编程的首选框架。 </p><p><strong>说说业务中，Netty 的使用场景</strong> </p><p>&gt; 构建高性能、低时延的各种Java中间件，例如MQ、分布式服务框架、ESB消息总线等，</p><p>Netty主要作为基础通信框架提供高性能、低时延的通信服务； </p><p>&gt; 公有或者私有协议栈的基础通信框架，例如可以基于Netty构建异步、高性能的</p><p>WebSocket协议栈； </p><p>&gt; 各领域应用，例如大数据、游戏等，Netty作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。 </p><p><strong>原生的 NIO 在 JDK 1.7 版本存在 epoll bug</strong></p><p>&gt; 它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK 1.6版本的update18修复了该问题，但是直到JDK 1.7版本该问题仍旧存在，只不过该BUG发生概率降低了一些而已，它并没有得到根本性解决。 </p><p><strong>什么是 TCP 粘包&#x2F;拆包</strong> </p><p>&gt; 1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。 </p><p>&gt; 2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。 </p><p>&gt; 3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。 </p><p>&gt; 4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 </p><p><strong>TCP</strong> <strong>粘包&#x2F;拆包的解决办法</strong> </p><p>&gt; 1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。 </p><p>&gt; 2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 </p><p>&gt; 3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。 </p><p><strong>Netty</strong> <strong>线程模型</strong> </p><p>&gt; 首先，Netty使用EventLoop来处理连接上的读写事件，而一个连接上的所有请求都保证在一个EventLoop中被处理，一个EventLoop中只有一个Thread，所以也就实现了一个连接上的所有事件只会在一个线程中被执行。一个EventLoopGroup包含多个EventLoop，可以把一个EventLoop当做是Reactor线程模型中的一个线程，而一个EventLoopGroup类似于一个ExecutorService </p><p><strong>说说 Netty 的零拷贝</strong> </p><p>&gt; “零拷贝”是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗资源。而</p><p>它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User </p><p>Space）而直接在内核空间（Kernel Space）中传输到网络的方式。 </p><p><strong>Netty</strong> <strong>内部执行流程</strong> </p><p>&gt; 1. Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行</p><p>Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP </p><p>BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入</p><p>Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p><p>&gt; 2. Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一</p><p>个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小</p><p>Buffer合并成一个大的Buffer。 </p><p>&gt; 3. Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/1MySQL55%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/1MySQL55%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1、一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，删除了第-15-16-17-条记录，再把-Mysql-重启，再-insert-一条记录，这条记录的-ID-是-18-还是-15-？"><a href="#1、一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，删除了第-15-16-17-条记录，再把-Mysql-重启，再-insert-一条记录，这条记录的-ID-是-18-还是-15-？" class="headerlink" title="1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？"></a>1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？</h2><p>(1)如果表的类型是 MyISAM，那么是 18 </p><p>因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里，重启 MySQL 自增主键的最大</p><p>ID 也不会丢失 </p><p>（2）如果表的类型是 InnoDB，那么是 15 </p><p>InnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或者是对表进行</p><p>OPTIMIZE 操作，都会导致最大 ID 丢失 </p><h2 id="2、-Mysql-的技术特点是什么？"><a href="#2、-Mysql-的技术特点是什么？" class="headerlink" title="2、   Mysql 的技术特点是什么？"></a>2、   Mysql 的技术特点是什么？</h2><p>Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多</p><p>线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。 </p><h2 id="3、-Heap-表是什么？"><a href="#3、-Heap-表是什么？" class="headerlink" title="3、   Heap 表是什么？"></a>3、   Heap 表是什么？</h2><p>HEAP 表存在于内存中，用于临时高速存储。 </p><p>BLOB 或 TEXT 字段是不允许的 </p><p>只能使用比较运算符&#x3D;，&lt;，&gt;，&#x3D;&gt;，&#x3D; &lt; </p><p>HEAP 表不支持 AUTO_INCREMENT 索引不可为 NULL </p><h2 id="4、-Mysql-服务器默认端口是什么？"><a href="#4、-Mysql-服务器默认端口是什么？" class="headerlink" title="4、   Mysql 服务器默认端口是什么？"></a>4、   Mysql 服务器默认端口是什么？</h2><p>Mysql 服务器的默认端口是 3306。 </p><h2 id="5、-与-Oracle-相比，Mysql-有什么优势？"><a href="#5、-与-Oracle-相比，Mysql-有什么优势？" class="headerlink" title="5、   与 Oracle 相比，Mysql 有什么优势？"></a>5、   与 Oracle 相比，Mysql 有什么优势？</h2><p>Mysql 是开源软件，随时可用，无需付费。 </p><p>Mysql 是便携式的带有命令提示符的 GUI。 </p><p>使用 Mysql 查询浏览器支持管理 </p><h2 id="6、-如何区分-FLOAT-和-DOUBLE？"><a href="#6、-如何区分-FLOAT-和-DOUBLE？" class="headerlink" title="6、   如何区分 FLOAT 和 DOUBLE？"></a>6、   如何区分 FLOAT 和 DOUBLE？</h2><p>以下是 FLOAT 和 DOUBLE 的区别： </p><p>浮点数以 8 位精度存储在 FLOAT 中，并且有四个字节。浮点数存储在 DOUBLE 中，精度为 18 位，有八个字节。 </p><h2 id="7、-区分-CHAR-LENGTH-和-LENGTH？"><a href="#7、-区分-CHAR-LENGTH-和-LENGTH？" class="headerlink" title="7、   区分 CHAR_LENGTH 和 LENGTH？"></a>7、   区分 CHAR_LENGTH 和 LENGTH？</h2><p>CHAR_LENGTH 是字符数，而 LENGTH 是字节数。Latin 字符的这两个数据是相同的，但是对于 Unicode 和其他编码，它们是不同的。 </p><h2 id="8、-请简洁描述-Mysql-中-InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？-SQL-标准定义的四个隔离级别为："><a href="#8、-请简洁描述-Mysql-中-InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？-SQL-标准定义的四个隔离级别为：" class="headerlink" title="8、   请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？ SQL 标准定义的四个隔离级别为："></a>8、   请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？ SQL 标准定义的四个隔离级别为：</h2><p>read uncommited ：读到未提交数据 read committed：脏读，不可重复读 repeatable read：可重读 serializable ：串行事物 </p><h2 id="9、-在-Mysql-中-ENUM-的用法是什么？"><a href="#9、-在-Mysql-中-ENUM-的用法是什么？" class="headerlink" title="9、   在 Mysql 中 ENUM 的用法是什么？"></a>9、   在 Mysql 中 ENUM 的用法是什么？</h2><p>ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。 </p><p>Create table size(name ENUM(‘Smail,’Medium’,’Large’); </p><h2 id="10、-如何定义-REGEXP？"><a href="#10、-如何定义-REGEXP？" class="headerlink" title="10、  如何定义 REGEXP？"></a>10、  如何定义 REGEXP？</h2><p>REGEXP 是模式匹配，其中匹配模式在搜索值的任何位置。 </p><h2 id="11、-CHAR-和-VARCHAR-的区别？"><a href="#11、-CHAR-和-VARCHAR-的区别？" class="headerlink" title="11、  CHAR 和 VARCHAR 的区别？"></a>11、  CHAR 和 VARCHAR 的区别？</h2><p>以下是 CHAR 和 VARCHAR 的区别： </p><p>CHAR 和 VARCHAR 类型在存储和检索方面有所不同 </p><p>CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255 </p><p>当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。 </p><h2 id="12、-列的字符串类型可以是什么？"><a href="#12、-列的字符串类型可以是什么？" class="headerlink" title="12、  列的字符串类型可以是什么？"></a>12、  列的字符串类型可以是什么？</h2><p>字符串类型是： </p><p>SET </p><p>BLOB </p><p>ENUM </p><p>CHAR </p><p>TEXT </p><p>VARCHAR </p><h2 id="13、-如何获取当前的-Mysql-版本？"><a href="#13、-如何获取当前的-Mysql-版本？" class="headerlink" title="13、  如何获取当前的 Mysql 版本？"></a>13、  如何获取当前的 Mysql 版本？</h2><p>SELECT VERSION();用于获取当前 Mysql 的版本。 </p><h2 id="14、-Mysql-中使用什么存储引擎？存储引擎称为表类型，数据使用各种技术存储在文件中。"><a href="#14、-Mysql-中使用什么存储引擎？存储引擎称为表类型，数据使用各种技术存储在文件中。" class="headerlink" title="14、  Mysql 中使用什么存储引擎？存储引擎称为表类型，数据使用各种技术存储在文件中。"></a>14、  Mysql 中使用什么存储引擎？存储引擎称为表类型，数据使用各种技术存储在文件中。</h2><p>技术涉及： </p><p>Storage mechanism </p><p>Locking levels </p><p>Indexing </p><p>Capabilities and functions. </p><h2 id="15、-Mysql-驱动程序是什么？"><a href="#15、-Mysql-驱动程序是什么？" class="headerlink" title="15、  Mysql 驱动程序是什么？"></a>15、  Mysql 驱动程序是什么？</h2><p>以下是 Mysql 中可用的驱动程序： </p><p>PHP 驱动程序 </p><p>JDBC 驱动程序 </p><p>ODBC 驱动程序 </p><p>CWRAPPER </p><p>PYTHON 驱动程序 </p><p>PERL 驱动程序 </p><p>RUBY 驱动程序 </p><p>CAP11PHP 驱动程序 </p><p>Ado.net5.mxj </p><h2 id="16、-TIMESTAMP-在-UPDATE-CURRENT-TIMESTAMP-数据类型上做什么？"><a href="#16、-TIMESTAMP-在-UPDATE-CURRENT-TIMESTAMP-数据类型上做什么？" class="headerlink" title="16、  TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？"></a>16、  TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？</h2><p>创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。 </p><h2 id="17、-主键和候选键有什么区别？"><a href="#17、-主键和候选键有什么区别？" class="headerlink" title="17、  主键和候选键有什么区别？"></a>17、  主键和候选键有什么区别？</h2><p> 表格的每一行都由主键唯一标识,一个表只有一个主键。 </p><p> 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。 </p><h2 id="18、-如何使用-Unix-shell-登录-Mysql？"><a href="#18、-如何使用-Unix-shell-登录-Mysql？" class="headerlink" title="18、  如何使用 Unix shell 登录 Mysql？"></a>18、  如何使用 Unix shell 登录 Mysql？</h2><p>我们可以通过以下命令登录： </p><p>[mysql dir]&#x2F;bin&#x2F;mysql -h hostname -u </p><h2 id="19、-myisamchk-是用来做什么的？"><a href="#19、-myisamchk-是用来做什么的？" class="headerlink" title="19、  myisamchk 是用来做什么的？"></a>19、  myisamchk 是用来做什么的？</h2><p> 它用来压缩 MyISAM 表，这减少了磁盘或内存使用。 </p><h2 id="20、-MYSQL-数据库服务器性能分析的方法命令有哪些"><a href="#20、-MYSQL-数据库服务器性能分析的方法命令有哪些" class="headerlink" title="20、  MYSQL 数据库服务器性能分析的方法命令有哪些?"></a>20、  MYSQL 数据库服务器性能分析的方法命令有哪些?</h2><h2 id="21、-如何控制-HEAP-表的最大尺寸？"><a href="#21、-如何控制-HEAP-表的最大尺寸？" class="headerlink" title="21、  如何控制 HEAP 表的最大尺寸？"></a>21、  如何控制 HEAP 表的最大尺寸？</h2><p>Heal 表的大小可通过称为 max_heap_table_size 的 Mysql 配置变量来控制。 </p><h2 id="22、-MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#22、-MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="22、  MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>22、  MyISAM Static 和 MyISAM Dynamic 有什么区别？</h2><p>在 MyISAM  Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。 </p><p>MyISAM Static 在受损情况下更容易恢复。 </p><h2 id="23、-federated-表是什么？"><a href="#23、-federated-表是什么？" class="headerlink" title="23、  federated 表是什么？"></a>23、  federated 表是什么？</h2><p>federated 表，允许访问位于其他服务器数据库上的表。 </p><h2 id="24、-如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#24、-如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="24、  如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>24、  如果一个表有一列定义为 TIMESTAMP，将发生什么？</h2><p>每当行被更改时，时间戳字段将获取当前时间戳。 </p><h2 id="25、-列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#25、-列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="25、  列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>25、  列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h2><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。 </p><h2 id="26、-怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#26、-怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="26、  怎样才能找出最后一次插入时分配了哪个自动增量？"></a>26、  怎样才能找出最后一次插入时分配了哪个自动增量？</h2><p>LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名称。 </p><h2 id="27、-你怎么看到为表格定义的所有索引？"><a href="#27、-你怎么看到为表格定义的所有索引？" class="headerlink" title="27、  你怎么看到为表格定义的所有索引？"></a>27、  你怎么看到为表格定义的所有索引？</h2><p>索引是通过以下方式为表格定义的： </p><p>SHOW INDEX FROM </p><h2 id="28-、LIKE-声明中的％和-是什么意思？"><a href="#28-、LIKE-声明中的％和-是什么意思？" class="headerlink" title="28.、LIKE 声明中的％和_是什么意思？"></a>28.、LIKE 声明中的％和_是什么意思？</h2><p>％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。 </p><h2 id="29、如何在-Unix-和-Mysql-时间戳之间进行转换？"><a href="#29、如何在-Unix-和-Mysql-时间戳之间进行转换？" class="headerlink" title="29、如何在 Unix 和 Mysql 时间戳之间进行转换？"></a>29、如何在 Unix 和 Mysql 时间戳之间进行转换？</h2><p>UNIX_TIMESTAMP 是从 Mysql 时间戳转换为 Unix 时间戳的命令 </p><p>FROM_UNIXTIME 是从 Unix 时间戳转换为 Mysql 时间戳的命令 </p><h2 id="30、列对比运算符是什么？"><a href="#30、列对比运算符是什么？" class="headerlink" title="30、列对比运算符是什么？"></a>30、列对比运算符是什么？</h2><p>在 SELECT 语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND，OR 或 LIKE 运算符。 </p><h2 id="31、我们如何得到受查询影响的行数？"><a href="#31、我们如何得到受查询影响的行数？" class="headerlink" title="31、我们如何得到受查询影响的行数？"></a>31、我们如何得到受查询影响的行数？</h2><p>行数可以通过以下代码获得： </p><p>SELECT COUNT(user_id)FROM users; </p><h2 id="32、Mysql-查询是否区分大小写？"><a href="#32、Mysql-查询是否区分大小写？" class="headerlink" title="32、Mysql 查询是否区分大小写？"></a>32、Mysql 查询是否区分大小写？</h2><p>不区分 </p><p>SELECT VERSION(), CURRENT_DATE; </p><p>SeLect version(), current_date; </p><p>seleCt vErSiOn(), current_DATE; </p><p> 所有这些例子都是一样的，Mysql 不区分大小写。 </p><h2 id="33-、LIKE-和-REGEXP-操作有什么区别？"><a href="#33-、LIKE-和-REGEXP-操作有什么区别？" class="headerlink" title="33.、LIKE 和 REGEXP 操作有什么区别？"></a>33.、LIKE 和 REGEXP 操作有什么区别？</h2><p>LIKE 和 REGEXP 运算符用于表示^和％。 </p><p>SELECT * FROM employee WHERE emp_name REGEXP “^b”; </p><p>SELECT * FROM employee WHERE emp_name LIKE “%b”; </p><h2 id="34-、BLOB-和-TEXT-有什么区别？"><a href="#34-、BLOB-和-TEXT-有什么区别？" class="headerlink" title="34.、BLOB 和 TEXT 有什么区别？"></a>34.、BLOB 和 TEXT 有什么区别？</h2><p>BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB - </p><p>TINYBLOB </p><p>BLOB </p><p>MEDIUMBLOB 和 LONGBLOB 它们只能在所能容纳价值的最大长度上有所不同。 </p><p>TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型 </p><p>TINYTEXT </p><p>TEXT </p><p>MEDIUMTEXT 和 LONGTEXT </p><p>它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。 </p><p>BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。 </p><h2 id="35、mysql-fetch-array-和-mysql-fetch-object-的区别是什么？"><a href="#35、mysql-fetch-array-和-mysql-fetch-object-的区别是什么？" class="headerlink" title="35、mysql_fetch_array 和 mysql_fetch_object 的区别是什么？"></a>35、mysql_fetch_array 和 mysql_fetch_object 的区别是什么？</h2><p>以下是 mysql_fetch_array 和 mysql_fetch_object 的区别： </p><p> mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。 </p><p> mysql_fetch_object - 从数据库返回结果行作为对象。 </p><h2 id="36、我们如何在-mysql-中运行批处理模式？"><a href="#36、我们如何在-mysql-中运行批处理模式？" class="headerlink" title="36、我们如何在 mysql 中运行批处理模式？"></a>36、我们如何在 mysql 中运行批处理模式？</h2><p>以下命令用于在批处理模式下运行： </p><p>mysql; </p><p>mysql mysql.out </p><h2 id="37、MyISAM-表格将在哪里存储，并且还提供其存储格式？"><a href="#37、MyISAM-表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="37、MyISAM 表格将在哪里存储，并且还提供其存储格式？"></a>37、MyISAM 表格将在哪里存储，并且还提供其存储格式？</h2><p>每个 MyISAM 表格以三种格式存储在磁盘上： </p><p>·“.frm”文件存储表定义 </p><p>·数据文件具有“.MYD”（MYData）扩展名 </p><p>索引文件具有“.MYI”（MYIndex）扩展名 </p><h2 id="38-、Mysql-中有哪些不同的表格？"><a href="#38-、Mysql-中有哪些不同的表格？" class="headerlink" title="38.、Mysql 中有哪些不同的表格？"></a>38.、Mysql 中有哪些不同的表格？</h2><p>共有 5 种类型的表格： </p><p>MyISAM </p><p>Heap </p><p>Merge </p><p>INNODB </p><p>ISAM </p><p>MyISAM 是 Mysql 的默认存储引擎。 </p><h2 id="39、ISAM-是什么？"><a href="#39、ISAM-是什么？" class="headerlink" title="39、ISAM 是什么？"></a>39、ISAM 是什么？</h2><p>ISAM 简称为索引顺序访问方法。它是由 IBM 开发的，用于在磁带等辅助存储系统上存储和检索数据。 </p><h2 id="40、InnoDB-是什么？"><a href="#40、InnoDB-是什么？" class="headerlink" title="40、InnoDB 是什么？"></a>40、InnoDB 是什么？</h2><p>lnnoDB 是一个由 Oracle 公司开发的 Innobase Oy 事务安全存储引擎。 </p><h2 id="41、Mysql-如何优化-DISTINCT？"><a href="#41、Mysql-如何优化-DISTINCT？" class="headerlink" title="41、Mysql 如何优化 DISTINCT？"></a>41、Mysql 如何优化 DISTINCT？</h2><p>DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。 </p><p>1 </p><p>SELECT DISTINCT t1.a FROM t1,t2 where t1.a&#x3D;t2.a; </p><h2 id="42、如何输入字符为十六进制数字？"><a href="#42、如何输入字符为十六进制数字？" class="headerlink" title="42、如何输入字符为十六进制数字？"></a>42、如何输入字符为十六进制数字？</h2><p>如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。 </p><p>如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。 </p><h2 id="43、如何显示前-50-行？"><a href="#43、如何显示前-50-行？" class="headerlink" title="43、如何显示前 50 行？"></a>43、如何显示前 50 行？</h2><p>在 Mysql 中，使用以下代码查询显示前 50 行： </p><p>SELECT*FROM </p><p>LIMIT 0,50; </p><h2 id="44、可以使用多少列创建索引？"><a href="#44、可以使用多少列创建索引？" class="headerlink" title="44、可以使用多少列创建索引？"></a>44、可以使用多少列创建索引？</h2><p>任何标准表最多可以创建 16 个索引列。 </p><h2 id="45、NOW（）和-CURRENT-DATE（）有什么区别？"><a href="#45、NOW（）和-CURRENT-DATE（）有什么区别？" class="headerlink" title="45、NOW（）和 CURRENT_DATE（）有什么区别？"></a>45、NOW（）和 CURRENT_DATE（）有什么区别？</h2><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。 </p><p>CURRENT_DATE（）仅显示当前年份，月份和日期。 </p><h2 id="46、什么样的对象可以使用-CREATE-语句创建？"><a href="#46、什么样的对象可以使用-CREATE-语句创建？" class="headerlink" title="46、什么样的对象可以使用 CREATE 语句创建？"></a>46、什么样的对象可以使用 CREATE 语句创建？</h2><p>以下对象是使用 CREATE 语句创建的： </p><p>DATABASE </p><p>EVENT </p><p>FUNCTION </p><p>INDEX </p><p>PROCEDURE </p><p>TABLE </p><p>TRIGGER </p><p>USER </p><p>VIEW </p><h2 id="47、Mysql-表中允许有多少个-TRIGGERS？"><a href="#47、Mysql-表中允许有多少个-TRIGGERS？" class="headerlink" title="47、Mysql 表中允许有多少个 TRIGGERS？"></a>47、Mysql 表中允许有多少个 TRIGGERS？</h2><p>在 Mysql 表中允许有六个触发器，如下： </p><p>BEFORE INSERT </p><p>AFTER INSERT </p><p>BEFORE UPDATE </p><p>AFTER UPDATE </p><p>BEFORE DELETE </p><p>AFTER DELETE </p><h2 id="48、什么是非标准字符串类型？"><a href="#48、什么是非标准字符串类型？" class="headerlink" title="48、什么是非标准字符串类型？"></a>48、什么是非标准字符串类型？</h2><p>以下是非标准字符串类型： </p><p>TINYTEXT </p><p>TEXT </p><p>MEDIUMTEXT </p><p>LONGTEXT </p><h2 id="49、什么是通用-SQL-函数？"><a href="#49、什么是通用-SQL-函数？" class="headerlink" title="49、什么是通用 SQL 函数？"></a>49、什么是通用 SQL 函数？</h2><p>CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。 </p><p>FORMAT(X, D)- 格式化数字 X 到 D 有效数字。 </p><p>CURRDATE(), CURRTIME()- 返回当前日期或时间。 </p><p>NOW（） - 将当前日期和时间作为一个值返回。 </p><p>MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中提取给定数据。 HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。 DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄 SUBTIMES（A，B） - 确定两次之间的差异。 </p><p>FROMDAYS（INT） - 将整数天数转换为日期值。 </p><h2 id="50、解释访问控制列表"><a href="#50、解释访问控制列表" class="headerlink" title="50、解释访问控制列表"></a>50、解释访问控制列表</h2><p>ACL（访问控制列表）是与对象关联的权限列表。这个列表是 Mysql 服务器安全模型的基础，它有助于排除用户无法连接的问题。 </p><p>Mysql 将 ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql 会按照预定的顺序检查 ACL 的认证信息和权限。 </p><h2 id="51、MYSQL-支持事务吗？"><a href="#51、MYSQL-支持事务吗？" class="headerlink" title="51、MYSQL 支持事务吗？"></a>51、MYSQL 支持事务吗？</h2><p>在缺省模式下，MYSQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql 是不支持事务的。 </p><p>但是如果你的 MYSQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的 MYSQL 就可以使用事务处理,使用 SET AUTOCOMMIT&#x3D;0 就可以使 MYSQL 允许在非 autocommit 模式，在非 autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK 来回滚你的更改。 </p><p>示例如下： </p><p>一 </p><p>START TRANSACTION; </p><p>SELECT @A:&#x3D;SUM(salary) FROM table1 WHERE type&#x3D;1; </p><p>UPDATE table2 SET summmary&#x3D;@A WHERE type&#x3D;1; </p><p>COMMIT; </p><h2 id="52、mysql-里记录货币用什么字段类型好"><a href="#52、mysql-里记录货币用什么字段类型好" class="headerlink" title="52、mysql 里记录货币用什么字段类型好"></a>52、mysql 里记录货币用什么字段类型好</h2><p>NUMERIC 和 DECIMAL 类型被 Mysql 实现为同样的类型，这在 SQL92 标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。 </p><p>例如： </p><p>salary DECIMAL(9,2) </p><p>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。 </p><p>因此，在这种情况下，能被存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。在 ANSI&#x2F;ISO SQL92 中，句法 DECIMAL(p)等价于 DECIMAL(p,0)。 </p><p>同样，句法 DECIMAL 等价于 DECIMAL(p,0)，这里实现被允许决定值 p。Mysql 当前不支持 DECIMAL&#x2F;NUMERIC 数据类型的这些变种形式的任一种。 </p><p>这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。 </p><p>DECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。 </p><p>一个字符用于值的每一位、小数点(如果 scale&gt;0)和“-”符号(对于负值)。如果 scale 是 0，</p><p>DECIMAL 和 NUMERIC 值不包含小数点或小数部分。 </p><p>DECIMAL 和 NUMERIC 值得最大的范围与 DOUBLE 一样，但是对于一个给定的 DECIMAL 或</p><p>NUMERIC 列，实际的范围可由制由给定列的 precision 或 scale 限制。 </p><p>当这样的列赋给了小数点后面的位超过指定 scale 所允许的位的值，该值根据 scale 四舍五入。 </p><p>当一个 DECIMAL 或 NUMERIC 列被赋给了其大小超过指定(或缺省的）precision 和 scale 隐含的范围的值，Mysql 存储表示那个范围的相应的端点值。 </p><p>我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。 </p><h2 id="53、MYSQL-数据表在什么情况下容易损坏？"><a href="#53、MYSQL-数据表在什么情况下容易损坏？" class="headerlink" title="53、MYSQL 数据表在什么情况下容易损坏？"></a>53、MYSQL 数据表在什么情况下容易损坏？</h2><p>服务器突然断电导致数据文件损坏。 </p><p>强制关机，没有先关闭 mysql 服务等。 </p><h2 id="54、mysql-有关权限的表都有哪几个？"><a href="#54、mysql-有关权限的表都有哪几个？" class="headerlink" title="54、mysql 有关权限的表都有哪几个？"></a>54、mysql 有关权限的表都有哪几个？</h2><p>Mysql 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由 mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。 </p><h2 id="55、Mysql-中有哪几种锁？"><a href="#55、Mysql-中有哪几种锁？" class="headerlink" title="55、Mysql 中有哪几种锁？"></a>55、Mysql 中有哪几种锁？</h2><p>MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁 </p><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低 </p><p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/1MyBatis%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/1MyBatis%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1、什么是-MyBatis？"><a href="#1、什么是-MyBatis？" class="headerlink" title="1、什么是 MyBatis？"></a>1、什么是 MyBatis？</h2><p>答：MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。 </p><h2 id="2、讲下-MyBatis-的缓存答"><a href="#2、讲下-MyBatis-的缓存答" class="headerlink" title="2、讲下 MyBatis 的缓存答"></a>2、讲下 MyBatis 的缓存答</h2><p>：MyBatis 的缓存分为一级缓存和二级缓存,一级缓存放在 session 里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> </p><h2 id="3、Mybatis-是如何进行分页的？分页插件的原理是什么？答："><a href="#3、Mybatis-是如何进行分页的？分页插件的原理是什么？答：" class="headerlink" title="3、Mybatis 是如何进行分页的？分页插件的原理是什么？答："></a>3、Mybatis 是如何进行分页的？分页插件的原理是什么？答：</h2><p>1）Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用</p><p>Mybatis 的分页插件。 </p><p>2）分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql。 </p><p>举例：select * from student，拦截 sql 后重写为：select t.* from （select * from student）t limit 0，10 </p><h2 id="4、简述-Mybatis-的插件运行原理，以及如何编写一个插件？答："><a href="#4、简述-Mybatis-的插件运行原理，以及如何编写一个插件？答：" class="headerlink" title="4、简述 Mybatis 的插件运行原理，以及如何编写一个插件？答："></a>4、简述 Mybatis 的插件运行原理，以及如何编写一个插件？答：</h2><p>1）Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、</p><p>Executor 这 4 种接口的插件，Mybatis 通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是</p><p>InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。 </p><p>2）实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。 </p><h2 id="5、Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？答："><a href="#5、Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？答：" class="headerlink" title="5、Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？答："></a>5、Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？答：</h2><p>1）Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。 </p><p>2）Mybatis 提供了 9 种动态 sql 标签：</p><p>trim|where|set|foreach|if|choose|when|otherwise|bind。 </p><p>3）其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。 </p><h2 id="6、-和-的区别是什么？答：-1）-是预编译处理，-是字符串替换。"><a href="#6、-和-的区别是什么？答：-1）-是预编译处理，-是字符串替换。" class="headerlink" title="6、#{}和${}的区别是什么？答： 1）#{}是预编译处理，${}是字符串替换。"></a>6、#{}和${}的区别是什么？答： 1）#{}是预编译处理，${}是字符串替换。</h2><p>2）Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值； </p><p>3）Mybatis 在处理${}时，就是把${}替换成变量的值。 </p><p>4）使用#{}可以有效的防止 SQL 注入，提高系统安全性。 </p><h2 id="7、为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#7、为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="7、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>7、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h2><p>答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。 </p><h2 id="8、Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？答："><a href="#8、Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？答：" class="headerlink" title="8、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？答："></a>8、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？答：</h2><p>1）  Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。 </p><p>2）  它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。 </p><h2 id="9、MyBatis-与-Hibernate-有哪些不同？答："><a href="#9、MyBatis-与-Hibernate-有哪些不同？答：" class="headerlink" title="9、MyBatis 与 Hibernate 有哪些不同？答："></a>9、MyBatis 与 Hibernate 有哪些不同？答：</h2><p>1）  Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，不过 mybatis 可以通过 XML 或注解方式灵活配置要运行的 sql 语句，并将 java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再映射生成 java 对象。 </p><p>2）  Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 sql 映射文件，工作量大。 </p><p>3）  Hibernate 对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是</p><p>Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O&#x2F;R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。 </p><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 </p><h2 id="10、MyBatis-的好处是什么？答："><a href="#10、MyBatis-的好处是什么？答：" class="headerlink" title="10、MyBatis 的好处是什么？答："></a>10、MyBatis 的好处是什么？答：</h2><p>1）  MyBatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写，给程序的维护带来了很大便利。 </p><p>2）  MyBatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 Java Bean 对象，大大简化了 Java 数据库编程的重复工作。 </p><p>3）  因为 MyBatis 需要程序员自己去编写 sql 语句，程序员可以结合数据库自身的特点灵活控制 sql 语句，因此能够实现比 Hibernate 等全自动 orm 框架更高的查询效率，能够完成复杂查询。 </p><h2 id="11、简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#11、简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="11、简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>11、简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h2><p>答：Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在</p><p>Xml 映射文件中，<parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultMap>标签会被解析为 ResultMap 对象，其每个子</p><p>元素会被解析为 ResultMapping 对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。 </p><h2 id="12、什么是-MyBatis-的接口绑定-有什么好处？"><a href="#12、什么是-MyBatis-的接口绑定-有什么好处？" class="headerlink" title="12、什么是 MyBatis 的接口绑定,有什么好处？"></a>12、什么是 MyBatis 的接口绑定,有什么好处？</h2><p>答：接口映射就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定,我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置. </p><h2 id="13、接口绑定有几种实现方式-分别是怎么实现的"><a href="#13、接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="13、接口绑定有几种实现方式,分别是怎么实现的?"></a>13、接口绑定有几种实现方式,分别是怎么实现的?</h2><p>答：接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上</p><p>@Select@Update 等注解里面包含 Sql 语句来绑定,另外一种就是通过 xml 里面写 SQL 来绑定,在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名. </p><h2 id="14、什么情况下用注解绑定-什么情况下用-xml-绑定？"><a href="#14、什么情况下用注解绑定-什么情况下用-xml-绑定？" class="headerlink" title="14、什么情况下用注解绑定,什么情况下用 xml 绑定？"></a>14、什么情况下用注解绑定,什么情况下用 xml 绑定？</h2><p>答：当 Sql 语句比较简单时候,用注解绑定；当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多 </p><h2 id="15、MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#15、MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="15、MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>15、MyBatis 实现一对一有几种方式?具体怎么操作的？</h2><p>答：有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面配置 association 节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键 id,去再另外一个表里面查询数据,也是通过 association 配置,但另外一个表的查询通过 select 属性配置。 </p><h2 id="16、Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"><a href="#16、Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？" class="headerlink" title="16、Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"></a>16、Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h2><p>答：能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。 </p><p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。 </p><h2 id="17、MyBatis-里面的动态-Sql-是怎么设定的-用什么语法"><a href="#17、MyBatis-里面的动态-Sql-是怎么设定的-用什么语法" class="headerlink" title="17、MyBatis 里面的动态 Sql 是怎么设定的?用什么语法?"></a>17、MyBatis 里面的动态 Sql 是怎么设定的?用什么语法?</h2><p>答：MyBatis 里面的动态 Sql 一般是通过 if 节点来实现,通过 OGNL 语法来实现,但是如果要写的完整,必须配合 where,trim 节点,where 节点是判断包含节点有内容就插入 where,否则不插入,trim 节点是用来判断如果动态语句是以 and 或 or 开始,那么会自动把这个 and 或者 or 取掉。 </p><h2 id="18、Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？答："><a href="#18、Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？答：" class="headerlink" title="18、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？答："></a>18、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？答：</h2><p>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。 </p><p>第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。 </p><p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。 </p><h2 id="19、Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#19、Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="19、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>19、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h2><p>答：还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、</p><p><selectKey>，加上动态 sql 的 9 个标签，</p><p>trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中<sql>为 sql 片段标签，通过<include>标签引入 sql 片段，<selectKey>为不支持自增的主键生成策略标签。 </p><h2 id="20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定-pojo？答："><a href="#20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定-pojo？答：" class="headerlink" title="20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定 pojo？答："></a>20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定 pojo？答：</h2><p>1）通过在查询的 sql 语句中定义字段名的别名。 </p><p>2）通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。 </p><h2 id="21、模糊查询-like-语句该怎么写答："><a href="#21、模糊查询-like-语句该怎么写答：" class="headerlink" title="21、模糊查询 like 语句该怎么写答："></a>21、模糊查询 like 语句该怎么写答：</h2><p>1）在 java 中拼接通配符，通过#{}赋值 </p><p>2）在 Sql 语句中拼接通配符 （不安全 会引起 Sql 注入） </p><h2 id="22、通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应-Dao-的工作原理，是否可以重载？"><a href="#22、通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应-Dao-的工作原理，是否可以重载？" class="headerlink" title="22、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应, Dao 的工作原理，是否可以重载？"></a>22、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应, Dao 的工作原理，是否可以重载？</h2><p>答：不能重载，因为通过 Dao 寻找 Xml 对应的 sql 的时候全限名+方法名的保存和寻找策略。接口工作原理为 jdk 动态代理原理，运行时会为 dao 生成 proxy，代理对象会拦截接口方法，去执行对应的 sql 返回数据。 </p><h2 id="23、Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#23、Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="23、Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>23、Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h2><p>答：虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。 </p><h2 id="24、Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？答：不同的-Xml-映射文件，如果配置了-namespace，那么-id-可以重复；如果没有配置"><a href="#24、Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？答：不同的-Xml-映射文件，如果配置了-namespace，那么-id-可以重复；如果没有配置" class="headerlink" title="24、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置"></a>24、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置</h2><p>namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。原因就是 namespace+id 是作为 Map&lt;String,  MappedStatement&gt;的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。 </p><h2 id="25、Mybatis-中如何执行批处理？"><a href="#25、Mybatis-中如何执行批处理？" class="headerlink" title="25、Mybatis 中如何执行批处理？"></a>25、Mybatis 中如何执行批处理？</h2><p>答：使用 BatchExecutor 完成批处理。 </p><h2 id="26、Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#26、Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="26、Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>26、Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>答：Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、</p><p>BatchExecutor。1）SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。2）ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map3）BatchExecutor：完成批处理。 </p><h2 id="27、Mybatis-中如何指定使用哪一种-Executor-执行器？"><a href="#27、Mybatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="27、Mybatis 中如何指定使用哪一种 Executor 执行器？"></a>27、Mybatis 中如何指定使用哪一种 Executor 执行器？</h2><p>答：在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给</p><p>DefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数。 </p><h2 id="28、Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#28、Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="28、Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>28、Mybatis 执行批量插入，能返回数据库主键列表吗？</h2><p>答：能，JDBC 都能，Mybatis 当然也能。 </p><h2 id="29、Mybatis-是否可以映射-Enum-枚举类？"><a href="#29、Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="29、Mybatis 是否可以映射 Enum 枚举类？"></a>29、Mybatis 是否可以映射 Enum 枚举类？</h2><p>答：Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和 getResult()接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。 </p><h2 id="30、如何获取自动生成的-主-键值？"><a href="#30、如何获取自动生成的-主-键值？" class="headerlink" title="30、如何获取自动生成的(主)键值？"></a>30、如何获取自动生成的(主)键值？</h2><p>答：配置文件设置 usegeneratedkeys 为 true </p><h2 id="31、在-mapper-中如何传递多个参数？答："><a href="#31、在-mapper-中如何传递多个参数？答：" class="headerlink" title="31、在 mapper 中如何传递多个参数？答："></a>31、在 mapper 中如何传递多个参数？答：</h2><p>1）直接在方法中传递参数，xml 文件用#{0} #{1}来获取 </p><p>2）使用 @param 注解:这样可以直接在 xml 文件中通过#{name}来获取 </p><h2 id="32、resultType-resultMap-的区别？"><a href="#32、resultType-resultMap-的区别？" class="headerlink" title="32、resultType resultMap 的区别？"></a>32、resultType resultMap 的区别？</h2><p>答： </p><p>1）类的名字和数据库相同时，可以直接设置 resultType 参数为 Pojo 类 </p><p>2）若不同，需要设置 resultMap 将结果名字和 Pojo 名字进行转换 </p><h2 id="33、使用-MyBatis-的-mapper-接口调用时有哪些要求？答："><a href="#33、使用-MyBatis-的-mapper-接口调用时有哪些要求？答：" class="headerlink" title="33、使用 MyBatis 的 mapper 接口调用时有哪些要求？答："></a>33、使用 MyBatis 的 mapper 接口调用时有哪些要求？答：</h2><p>1）Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同 </p><p>2）Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的类型相同 </p><p>3）Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型相同 </p><p>4）Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。 </p><h2 id="34、Mybatis-比-IBatis-比较大的几个改进是什么？答："><a href="#34、Mybatis-比-IBatis-比较大的几个改进是什么？答：" class="headerlink" title="34、Mybatis 比 IBatis 比较大的几个改进是什么？答："></a>34、Mybatis 比 IBatis 比较大的几个改进是什么？答：</h2><p>1）有接口绑定,包括注解绑定 sql 和 xml 绑定 Sql  </p><p>2）动态 sql 由原来的节点配置变成 OGNL 表达式 3）    在一对一,一对多的时候引进了</p><p>association,在一对多的时候引入了 collection 节点,不过都是在 resultMap 里面配置 </p><h2 id="35、-IBatis-和-MyBatis-在核心处理类分别叫什么？"><a href="#35、-IBatis-和-MyBatis-在核心处理类分别叫什么？" class="headerlink" title="35、      IBatis 和 MyBatis 在核心处理类分别叫什么？"></a>35、      IBatis 和 MyBatis 在核心处理类分别叫什么？</h2><p>答：IBatis 里面的核心处理类交 SqlMapClient,MyBatis 里面的核心处理类叫做 SqlSession。 </p><h2 id="36、-IBatis-和-MyBatis-在细节上的不同有哪些？答："><a href="#36、-IBatis-和-MyBatis-在细节上的不同有哪些？答：" class="headerlink" title="36、      IBatis 和 MyBatis 在细节上的不同有哪些？答："></a>36、      IBatis 和 MyBatis 在细节上的不同有哪些？答：</h2><p>1）在 sql 里面变量命名有原来的#变量# 变成了#{变量} </p><p>2）原来的$变量$变成了${变量} </p><p>3）原来在 sql 节点里面的 class 都换名字交 type </p><p>4）原来的 queryForObject queryForList 变成了 selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/1java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/1java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="java-后端面试题答案-lt-1-gt"><a href="#java-后端面试题答案-lt-1-gt" class="headerlink" title="java 后端面试题答案&lt;1&gt;"></a>java 后端面试题答案&lt;1&gt;</h1><p>说明：以下所有答案均为个人的理解和网上的一些资料的整合</p><h2 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h2><p>List , Set 都是继承自 Collection 接口 List 特点：元素有放入顺序，元素可重复 ，</p><p>Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素的 HashCode 决定的，其位置其实是固定的，加入Set 的 Object 必须定义 equals ()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。） Set和List对比 Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p><h2 id="HashSet-是如何保证不重复的"><a href="#HashSet-是如何保证不重复的" class="headerlink" title="HashSet 是如何保证不重复的"></a>HashSet 是如何保证不重复的</h2><p>向 HashSet 中 add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合 equles 方法比较。</p><p>HashSet 中的 add ()方法会使用 HashMap 的 add ()方法。以下是 HashSet 部分源码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private static final Object PRESENT = new Object(); private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">public HashSet() &#123;</span><br><span class="line">map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashMap 的 key 是唯一的，由上面的代码可以看出 HashSet 添加进去的值就是作为 HashMap 的key。所以不会重复（ HashMap 比较key是否相等是先比较 hashcode 在比较 equals ）。</code></p><h2 id="HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）-不是线程安全的；"><a href="#HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）-不是线程安全的；" class="headerlink" title="HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?不是线程安全的；"></a>HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?不是线程安全的；</h2><p>如果有两个线程A和B，都进行插入数据，刚好这两条不同的数据经过哈希计算后得到的哈希码是一样的，且该位置还没有其他的数据。所以这两个线程都会进入我在上面标记为1的代码中。假设一种情况，线程A通过if判断，该位置没有哈希冲突，进入了if语句，还没有进行数据插入，这时候 CPU 就把资源让给了线程B，线程A停在了if语句里面，线程B判断该位置没有哈希冲突（线程A的数据还没插入），也进入了if语句，线程B执行完后，轮到线程A执行，现在线程A直接在该位置插入而不用再判断。这时候，你会发现线程A把线程B插入的数据给覆盖了。发生了线程不安全情况。本来在 HashMap 中，发生哈希冲突是可以用链表法或者红黑树来解决的，但是在多线程中，可能就直接给覆盖了。</p><p>上面所说的是一个图来解释可能更加直观。如下面所示，两个线程在同一个位置添加数据，后面添加的数据就覆盖住了前面添加的。</p><p><img src="/1java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.assets/1.jpg" alt="1"></p><p>如果上述插入是插入到链表上，如两个线程都在遍历到最后一个节点，都要在最后添加一个数据，那么后面添加数据的线程就会把前面添加的数据给覆盖住。则<img src="/1java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.assets/2.jpg" alt="2"></p><p>在扩容的时候也可能会导致数据不一致，因为扩容是从一个数组拷贝到另外一个数组。</p><h2 id="HashMap-的扩容过程"><a href="#HashMap-的扩容过程" class="headerlink" title="HashMap 的扩容过程"></a>HashMap 的扩容过程</h2><p>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值(知道这个阈字怎么念吗？不念 fa 值，念 yu 值四声)—即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。</p><p>扩容( resize )就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p><code>HashMap hashMap=new HashMap(cap);</code></p><p>cap &#x3D;3， hashMap 的容量为4；</p><p>cap &#x3D;4， hashMap 的容量为4；</p><p>cap &#x3D;5， hashMap 的容量为8；</p><p>cap &#x3D;9， hashMap 的容量为16；</p><p>如果 cap 是2的n次方，则容量为 cap ，否则为大于 cap 的第一个2的n次方的数。</p><h2 id="HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><a href="#HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？" class="headerlink" title="HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？"></a>HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</h2><p>HashMap结构图<img src="/1java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.assets/3.jpg" alt="3"></p><p>在 JDK1.7 及之前的版本中， HashMap 又叫散列链表：基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。 </p><p>JDK1.8 中，当同一个hash值（ Table 上元素）的链表节点数不小于8时，将不再以单链表的形式存储了，会被</p><p>调整成一颗红黑树。这就是 JDK7 与 JDK8 中 HashMap 实现的最大区别。 </p><p>其下基于 JDK1.7.0_80 与 JDK1.8.0_66 做的分析</p><p>JDK1.7中</p><p>使用一个 Entry 数组来存储数据，用key的 hashcode 取模来决定key会被放到数组里的位置，如果 hashcode 相同，或者 hashcode 取模后的结果相同（ hash collision ），那么这些 key 会被定位到 Entry 数组的同一个格子里，这些 key 会形成一个链表。</p><p>在 hashcode 特别差的情况下，比方说所有key的 hashcode 都相同，这个链表可能会很长，那么 put&#x2F;get 操作都可能需要遍历这个链表，也就是说时间复杂度在最差情况下会退化到 O(n)</p><p>JDK1.8中 </p><p>使用一个 Node 数组来存储数据，但这个 Node 可能是链表结构，也可能是红黑树结构</p><ul><li>如果插入的 key 的 hashcode 相同，那么这些key也会被定位到 Node 数组的同一个格子里。</li><li>如果同一个格子里的key不超过8个，使用链表结构存储。</li><li>如果超过了8个，那么会调用 treeifyBin 函数，将链表转换为红黑树。</li></ul><p>那么即使 hashcode 完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销也就是说put&#x2F;get的操作的时间复杂度最差只有 O(log n)</p><p>听起来挺不错，但是真正想要利用 JDK1.8 的好处，有一个限制：key的对象，必须正确的实现了 Compare 接口</p><p>如果没有实现 Compare 接口，或者实现得不正确（比方说所有 Compare 方法都返回0）那 JDK1.8 的 HashMap 其实还是慢于 JDK1.7 的</p><p>简单的测试数据如下：</p><p>向 HashMap 中 put&#x2F;get 1w 条 hashcode 相同的对象</p><p>JDK1.7: put 0.26s ， get 0.55s</p><p>JDK1.8 （未实现 Compare 接口）： put 0.92s ， get 2.1s</p><p>但是如果正确的实现了 Compare 接口，那么 JDK1.8 中的 HashMap 的性能有巨大提升，这次 put&#x2F;get 100W条hashcode 相同的对象</p><p>JDK1.8 （正确实现 Compare 接口，）： put&#x2F;get 大概开销都在320 ms 左右</p><p><code>final finally finalize</code></p><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用 System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li></ul><h2 id="对象的四种引用"><a href="#对象的四种引用" class="headerlink" title="对象的四种引用"></a>对象的四种引用</h2><p>强引用 只要引用存在，垃圾回收器永远不会回收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object(); </span><br><span class="line">User user=new User();</span><br></pre></td></tr></table></figure><p>可直接通过obj取得对应的对象 如 obj.equels(new Object()); 而这样 obj 对象对后面 new Object 的一个强引用，只有当 obj 这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。</p><p>软引用 非必须引用，内存溢出之前进行回收，可以通过以下代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br><span class="line">sf.get();//有时候会返回null</span><br></pre></td></tr></table></figure><p>这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null； 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</p><p>弱引用 第二次垃圾回收时回收，可以通过如下代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br><span class="line">wf.get();//有时候会返回null</span><br><span class="line">wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾</span><br></pre></td></tr></table></figure><p>弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，</p><p>将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的</p><p>isEnQueued 方法返回对象是否被垃圾回收器标记。ThreadLocal 中有使用到弱引用，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value;</span><br><span class="line">Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">super(k); value = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//....</span><br><span class="line">&#125;</span><br><span class="line">//.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚引用 垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj=null;</span><br><span class="line">pf.get();//永远返回null pf.isEnQueued();//返回是否从内存中已经删除</span><br></pre></td></tr></table></figure><p>虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。</p><h2 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h2><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123; </span><br><span class="line">private int id; </span><br><span class="line">String name;</span><br><span class="line">protected boolean sex; </span><br><span class="line">public float score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Get &#123;</span><br><span class="line">//获取反射机制三种方式</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">//方式一(通过建立对象)</span><br><span class="line"></span><br><span class="line">Student stu = new Student();</span><br><span class="line"></span><br><span class="line">Class classobj1 = stu.getClass(); </span><br><span class="line">System.out.println(classobj1.getName()); //方式二（所在通过路径-相对路径）</span><br><span class="line"></span><br><span class="line">Class classobj2 = Class.forName(&quot;fanshe.Student&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(classobj2.getName());</span><br><span class="line">//方式三（通过类名）</span><br><span class="line"></span><br><span class="line">Class classobj3 = Student.class; </span><br><span class="line">System.out.println(classobj3.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h2><p>Java 反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为 Java 的反射机制。</p><p>Class 类与 java.lang.reflect 类库一起对反射的概念进行了支持，该类库包含了 Field,Method,Constructor 类 (每个类都实现了 Member 接口)。这些类型的对象时由 JVM 在运行时创建的，用以表示未知类里对应的成员。</p><p>这样你就可以使用 Constructor 创建新的对象，用 get() 和 set() 方法读取和修改与 Field 对象关联的字段，用invoke() 方法调用与 Method 对象关联的方法。另外，还可以调用 getFields() getMethods() 和</p><p>getConstructors() 等很便利的方法，以返回表示字段，方法，以及构造器的对象的数组。这样匿名对象的信息</p><p>就能在运行时被完全确定下来，而在编译时不需要知道任何事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">public class ReflectTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Class clazz = null;</span><br><span class="line"></span><br><span class="line">clazz = Class.forName(&quot;com.jas.reflect.Fruit&quot;); </span><br><span class="line">Constructor&lt;Fruit&gt; constructor1 = clazz.getConstructor();</span><br><span class="line">Constructor&lt;Fruit&gt; constructor2 = clazz.getConstructor(String.class);</span><br><span class="line"></span><br><span class="line">Fruit fruit1 = constructor1.newInstance();</span><br><span class="line"></span><br><span class="line">Fruit fruit2 = constructor2.newInstance(&quot;Apple&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit&#123;</span><br><span class="line"></span><br><span class="line">public Fruit()&#123;</span><br><span class="line">System.out.println(&quot;无参构造器  Run...........&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Fruit(String type)&#123;</span><br><span class="line">System.out.println(&quot;有参构造器  Run...........&quot; + type);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>运行结果： 无参构造器 Run……….. 有参构造器 Run………..Apple </code></p><h2 id="Arrays-sort-和-Collections-sort-实现原理-和区别"><a href="#Arrays-sort-和-Collections-sort-实现原理-和区别" class="headerlink" title="Arrays.sort 和 Collections.sort 实现原理 和区别"></a>Arrays.sort 和 Collections.sort 实现原理 和区别</h2><p>Collection和Collections区别</p><p>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。</p><p>java.util.Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全等操作。 然后还有混排（Shuffling）、反转（Reverse）、替换所有的元素（fill）、拷贝（copy）、返回Collections中最小元素（min）、返回Collections中最大元素（max）、返回指定源列表中最后一次出现指定目标列表的起始位置（ lastIndexOfSubList ）、返回指定源列表中第一次出现指定目标列表的起始位置（ IndexOfSubList ）、根据指定的距离循环移动指定列表中的元素（Rotate）;</p><p>事实上Collections.sort方法底层就是调用的array.sort方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Object[] a) &#123;</span><br><span class="line"></span><br><span class="line">if (LegacyMergeSort.userRequested)</span><br><span class="line">legacyMergeSort(a);</span><br><span class="line">else</span><br><span class="line">ComparableTimSort.sort(a, 0, a.length, null, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//void java.util.ComparableTimSort.sort()</span><br><span class="line">static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123;</span><br><span class="line"></span><br><span class="line">assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; </span><br><span class="line">int nRemaining = hi - lo;</span><br><span class="line">if (nRemaining &lt; 2)</span><br><span class="line"></span><br><span class="line">return; // Arrays of size 0 and 1 are always sorted</span><br><span class="line"></span><br><span class="line">// If array is small, do a &quot;mini-TimSort&quot; with no merges </span><br><span class="line">if (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">int initRunLen = countRunAndMakeAscending(a, lo, hi); </span><br><span class="line">binarySort(a, lo, hi, lo + initRunLen);</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>legacyMergeSort (a)：归并排序 ComparableTimSort.sort() ： Timsort 排序</p><p>Timsort 排序是结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法</p><p>Timsort的核心过程</p><blockquote><p>TimSort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的数字，而是一个个的块-分区。其中每一个分区叫一个run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run合并到只剩一个 run 为止。这时这个仅剩的run 便是排好序的结果。</p></blockquote><p>综上述过程，Timsort算法的过程包括</p><p>（0）如何数组长度小于某个值，直接用二分插入排序算法</p><p>（1）找到各个run，并入栈</p><p>（2）按规则合并run</p><h2 id="LinkedHashMap-的应用"><a href="#LinkedHashMap-的应用" class="headerlink" title="LinkedHashMap 的应用"></a>LinkedHashMap 的应用</h2><p>基于 LinkedHashMap 的访问顺序的特点，可构造一个 LRU（Least Recently Used） 最近最少使用简单缓存。也有一些开源的缓存产品如 ehcache 的淘汰策略（ LRU ）就是在 LinkedHashMap 上扩展的。</p><h2 id="Cloneable-接口实现原理"><a href="#Cloneable-接口实现原理" class="headerlink" title="Cloneable 接口实现原理"></a>Cloneable 接口实现原理</h2><p>Cloneable接口是Java开发中常用的一个接口， 它的作用是使一个类的实例能够将自身拷贝到另一个新的实例中，注意，这里所说的“拷贝”拷的是对象实例，而不是类的定义，进一步说，拷贝的是一个类的实例中各字段的值。</p><p><code>在开发过程中，拷贝实例是常见的一种操作，如果一个类中的字段较多，而我们又采用在客户端中逐字段复制的方法进行拷贝操作的话，将不可避免的造成客户端代码繁杂冗长，而且也无法对类中的私有成员进行复制，而如果让需要具备拷贝功能的类实现Cloneable接口，并重写clone()方法，就可以通过调用clone()方法的方式简洁地实现实例拷贝功能</code></p><p>深拷贝(深复制)和浅拷贝(浅复制)是两个比较通用的概念，尤其在C++语言中，若不弄懂，则会在delete的时候出问题，但是我们在这幸好用的是Java。虽然Java自动管理对象的回收，但对于深拷贝(深复制)和浅拷贝(浅复制)，我们还是要给予足够的重视，因为有时这两个概念往往会给我们带来不小的困惑。</p><p>浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象 A1 中包含对 B1 的引用， B1 中包含对 C1 的引用。浅拷贝 A1 得到 A2 ， A2 中依然包含对 B1 的引用， B1 中依然包含对 C1 的引用。深拷贝则是对浅拷贝的递归，深拷贝 A1 得到 A2 ， A2 中包含对 B2 （ B1 的 copy ）的引用， B2 中包含对 C2 （ C1 的 copy ）的引用。</p><p>若不对clone()方法进行改写，则调用此方法得到的对象即为浅拷贝</p><h2 id="异常分类以及处理机制"><a href="#异常分类以及处理机制" class="headerlink" title="异常分类以及处理机制"></a>异常分类以及处理机制</h2><p><img src="/1java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.assets/4.jpg" alt="4"></p><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。Throwable又派生出Error类和Exception类。</p><p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p><p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/27/zookeeper%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2022/04/27/zookeeper%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-ZooKeeper-是什么？"><a href="#1-ZooKeeper-是什么？" class="headerlink" title="1.ZooKeeper 是什么？"></a>1.ZooKeeper 是什么？</h1><p>ZooKeeper 是一个<em><strong>分布式*<strong>的，开放源码的分布式</strong>*应用程序协调服务**<em>，是 Google 的 Chubby 一个开源的实现，它是</em></strong>集群的管理者*<strong>，</strong></em>监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作***。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 </p><p>客户端的**<em>读请求*<strong>可以被集群中的</strong></em>任意一台机器处理***，如果读请求在节点上注册了监听器，这个监听器也是由所</p><p>连接的 zookeeper 机器来处理。对于*<strong>写请求*<strong>，这些请求会同</strong>*时发给其他zookeeper机器并且达成一致后，请求才会返回成功**<em>。因此，随着</em></strong>zookeeper***<em><strong>的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降*<strong>。有序性是 zookeeper 中非常重要的一个特性，所有的</strong>*更新都是全局有序的**<em>，每个更新都有一个</em></strong>唯一的时间戳*<strong>，这个时间戳称为</strong></em>zxid****<strong>（Zookeeper Transaction Id）*<strong>。而</strong>*读请求只会相对于更新有序**<em>，也就是读请求的返回结果中会带有这个</em></strong>zookeeper******最新的zxid***。 </p><h1 id="2-ZooKeeper-提供了什么？"><a href="#2-ZooKeeper-提供了什么？" class="headerlink" title="2.ZooKeeper 提供了什么？"></a>2.ZooKeeper 提供了什么？</h1><p>1、  *<strong>文件系统*</strong> </p><p>2、  *<strong>通知机制*</strong> </p><h1 id="3-Zookeeper-文件系统"><a href="#3-Zookeeper-文件系统" class="headerlink" title="3.Zookeeper 文件系统"></a>3.Zookeeper 文件系统</h1><p>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点***都可以设置关联的数据***，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper 为了保证高吞吐和低延</p><p>迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper**<em>不能用于存放大量的数据*<strong>，每个节点的存放数据上限为</strong></em>1M***。 </p><h1 id="4-四种类型的-znode"><a href="#4-四种类型的-znode" class="headerlink" title="4.四种类型的 znode"></a>4.四种类型的 znode</h1><p>1、  ***PERSISTENT-****<strong>持久化目录节点*</strong> </p><p>客户端与 zookeeper 断开连接后，该节点依旧存在  </p><p>2、  ***PERSISTENT_SEQUENTIAL-****<strong>持久化顺序编号目录节点*</strong> </p><p>客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号  </p><p>3、  ***EPHEMERAL-****<strong>临时目录节点*</strong> </p><p>客户端与 zookeeper 断开连接后，该节点被删除  </p><p>4、  ***EPHEMERAL_SEQUENTIAL-****<strong>临时顺序编号目录节点*</strong> </p><p>客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号 </p><p><img src="/zookeeper%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.assets/1.jpg" alt="1"></p><h1 id="5-Zookeeper-通知机制"><a href="#5-Zookeeper-通知机制" class="headerlink" title="5.Zookeeper 通知机制"></a>5.Zookeeper 通知机制</h1><p>client 端会对某个 znode 建立一个***watcher******事件***，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。 </p><h1 id="6-Zookeeper-做了什么？"><a href="#6-Zookeeper-做了什么？" class="headerlink" title="6.Zookeeper 做了什么？"></a>6.Zookeeper 做了什么？</h1><p>1、命名服务</p><p>2、配置管理</p><p>3、集群管理</p><p>4、分布式锁</p><p>5、队列管理</p><h1 id="7-zk-的命名服务（文件系统）"><a href="#7-zk-的命名服务（文件系统）" class="headerlink" title="7.zk 的命名服务（文件系统）"></a>7.zk 的命名服务（文件系统）</h1><p>命名服务是指通过指定的名字来*<strong>获取资源*<strong>或者</strong>*服务的地址**<em>，利用 zk 创建一个全局的路径，即是</em></strong>唯一***的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。 </p><h1 id="8-zk-的配置管理（文件系统、通知机制）"><a href="#8-zk-的配置管理（文件系统、通知机制）" class="headerlink" title="8.zk 的配置管理（文件系统、通知机制）"></a>8.zk 的配置管理（文件系统、通知机制）</h1><p>程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的***znode***下，当有配置发生改变时，也就是</p><p>znode 发生变化时，可以通过改变 zk 中某个目录节点的内容，利用***watcher***通知给各个客户端，从而更改配置。 </p><h1 id="9-Zookeeper-集群管理（文件系统、通知机制）"><a href="#9-Zookeeper-集群管理（文件系统、通知机制）" class="headerlink" title="9.Zookeeper 集群管理（文件系统、通知机制）"></a>9.Zookeeper 集群管理（文件系统、通知机制）</h1><p>所谓集群管理无在乎两点：***是否有机器退出和加入、选举master***。 </p><p>对于第一点，所有机器约定在父目录下***创建临时目录节点***，然后监听父目录节点的子节点变化消息。一旦有机</p><p>器挂掉，该机器与 zookeeper 的连接断开，其所创建的临时目录节点被删除，***所有其他机器都收到通知：某个兄弟目录被删除***，于是，所有人都知道：它上船了。 </p><p>新机器加入也是类似，**<em>所有机器收到通知：新兄弟目录加入*<strong>，highcount 又有了，对于第二点，我们稍微改变一下，</strong></em>所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好***。 </p><h1 id="10-Zookeeper-分布式锁（文件系统、通知机制）"><a href="#10-Zookeeper-分布式锁（文件系统、通知机制）" class="headerlink" title="10.Zookeeper 分布式锁（文件系统、通知机制）"></a>10.Zookeeper 分布式锁（文件系统、通知机制）</h1><p>有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是**<em>保持独占*<strong>，另一个是</strong></em>控制时序***。 </p><p>对于第一类，我们将 zookeeper 上的一个***znode******看作是一把锁***，通过 createznode 的方式来实现。所有客户</p><p>端都去创建 &#x2F;distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 distribute_lock 节点就释放出锁。  </p><p>对于第二类， &#x2F;distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选 master 一样，***编号最小的获得锁***，用完删除，依次方便。 </p><h1 id="11-获取分布式锁的流程"><a href="#11-获取分布式锁的流程" class="headerlink" title="11.获取分布式锁的流程"></a>11.获取分布式锁的流程</h1><p><img src="/zookeeper%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.assets/2.jpg" alt="2"></p><p>在获取分布式锁的时候在 locker 节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用 createNode 方法在 locker 下创建临时顺序节点， </p><p>然后调用 getChildren(“locker”)来获取 locker 下面的所有子节点，注意此时不用设置任何 Watcher。客户端获取到所有的子节点 path 之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非 locker 所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到**<em>比自己小的那个节点*<strong>，然后对其调用</strong></em>exist()***方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的 Watcher 会收到相应通知，此时再次判断自己创建的节点是否是 locker 子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。 </p><p><img src="/zookeeper%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.assets/3.jpg" alt="3"></p><p>代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于***BaseDistributedLock***，实现了基于Zookeeper 实现分布式锁的细节。 </p><h1 id="12-Zookeeper-队列管理（文件系统、通知机制）"><a href="#12-Zookeeper-队列管理（文件系统、通知机制）" class="headerlink" title="12.Zookeeper 队列管理（文件系统、通知机制）"></a>12.Zookeeper 队列管理（文件系统、通知机制）</h1><p>两种类型的队列： </p><p>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。 </p><p>2、队列按照 FIFO 方式进行入队和出队操作。 </p><p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。  </p><p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建</p><p>*<strong>PERSISTENT_SEQUENTIAL*<strong>节点，创建成功时</strong>*Watcher**<em>通知等待的队列，队列删除</em></strong>序列号最小的节点***用以消费。此场景下 Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内容，</p><p>SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以***不必担心队列消息的丢失问题***。 </p><h1 id="13-Zookeeper-数据复制"><a href="#13-Zookeeper-数据复制" class="headerlink" title="13.Zookeeper 数据复制"></a>13.Zookeeper 数据复制</h1><p>Zookeeper 作为一个集群提供一致的数据服务，自然，它要在***所有机器间***做数据复制。数据复制的好处： </p><p>1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作； </p><p>2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力； </p><p>3、提高性能：让***客户端本地访问就近的节点，提高用户访问速度***。 </p><p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：  </p><p>1、  <em><strong>写主*</strong>(WriteMaster) ：对数据的</em>*<em>修改提交给指定的节点*<strong>。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称</strong></em>读写分离***； </p><p>2、  <em><strong>写任意*</strong>(Write Any)：对数据的</em>**修改可提交给任意的节点***，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。 </p><p>对 zookeeper 来说，它采用的方式是*<strong>写任意*<strong>。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立 observer 的原因），而响应能力则取决于具体实现方式，是</strong>*延迟复制保持最终一致性**<em>，还是</em></strong>立即复制快速响应***。 </p><h1 id="14-Zookeeper-工作原理"><a href="#14-Zookeeper-工作原理" class="headerlink" title="14.Zookeeper 工作原理"></a>14.Zookeeper 工作原理</h1><p>Zookeeper 的核心是*<strong>原子广播*<strong>，这个机制保证了</strong>*各个Server之间的同步**<em>。实现这个机制的协议叫做</em></strong>Zab****<strong>协议*<strong>。Zab 协议有两种模式，它们分别是</strong>*恢复模式（选主）**<em>和</em></strong>广播模式（同步）***。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。 </p><h1 id="15-zookeeper-是如何保证事务的顺序一致性的？"><a href="#15-zookeeper-是如何保证事务的顺序一致性的？" class="headerlink" title="15.zookeeper 是如何保证事务的顺序一致性的？"></a>15.zookeeper 是如何保证事务的顺序一致性的？</h1><p>zookeeper 采用了**<em>递增的事务Id*<strong>来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时期; 纪元; 世; 新时代）用来标识 leader 是否发生改变，如果有新的 leader 产生出来，epoch 会自增，</strong></em>低32位用来递增计数***。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。 </p><h1 id="16-Zookeeper-下-Server-工作状态"><a href="#16-Zookeeper-下-Server-工作状态" class="headerlink" title="16.Zookeeper 下 Server 工作状态"></a>16.Zookeeper 下 Server 工作状态</h1><p>每个 Server 在工作过程中有三种状态：  </p><p>LOOKING：当前 Server***不知道leader是谁***，正在搜寻 </p><p>LEADING：当前 Server 即为选举出来的 leader </p><p>FOLLOWING：leader 已经选举出来，当前 Server 与之同步 </p><h1 id="17-zookeeper-是如何选取主-leader-的？"><a href="#17-zookeeper-是如何选取主-leader-的？" class="headerlink" title="17.zookeeper 是如何选取主 leader 的？"></a>17.zookeeper 是如何选取主 leader 的？</h1><p>当 leader 崩溃或者 leader 失去大多数的 follower，这时 zk 进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 Server 都恢复到一个正确的状态。Zk 的选举算法有两种：一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的。系统默认的选举算法为***fast paxos***。 </p><p>1、Zookeeper 选主流程(basic paxos) </p><p>（1）    选举线程由当前 Server 发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；  </p><p>（2）    选举线程首先向所有 Server 发起一次询问(包括自己)；  </p><p>（3）    选举线程收到回复后，验证是否是自己发起的询问(验证 zxid 是否一致)，然后获取对方的 id(myid)，并存储到当前询问对象列表中，最后获取对方提议的 leader 相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；  </p><p>（4）    收到所有 Server 回复以后，就计算出 zxid 最大的那个 Server，并将这个 Server 相关信息设置成下一次要投票的 Server；  </p><p>（5）    线程将当前 zxid 最大的 Server 设置为当前 Server 要推荐的 Leader，如果此时获胜的 Server 获得 n&#x2F;2 + 1 的 Server 票数，设置当前推荐的 leader 为获胜的 Server，将根据获胜的 Server 相关信息设置自己的状态，否则，继续这个过程，直到 leader 被选举出来。 通过流程分析我们可以得出：要使 Leader 获得多数Server 的支持，则 Server 总数必须是奇数 2n+1，且存活的 Server 的数目不得少于 n+1. 每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。 </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
